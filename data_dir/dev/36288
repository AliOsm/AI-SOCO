#include<bits/stdc++.h>
using namespace std;

template <int MOD_> struct modnum {
	static constexpr int MOD = MOD_;
	static_assert(MOD_ > 0, "MOD must be positive");

private:
	using ll = long long;

	int v;

	static int minv(int a, int m) {
		a %= m;
		assert(a);
		return a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);
	}

public:

	modnum() : v(0) {}
	modnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }
	explicit operator int() const { return v; }
	friend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }
	friend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }

	friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }
	friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }

	modnum inv() const {
		modnum res;
		res.v = minv(v, MOD);
		return res;
	}
	modnum neg() const {
		modnum res;
		res.v = v ? MOD-v : 0;
		return res;
	}

	modnum operator- () const {
		return neg();
	}
	modnum operator+ () const {
		return modnum(*this);
	}

	modnum& operator ++ () {
		v ++;
		if (v == MOD) v = 0;
		return *this;
	}
	modnum& operator -- () {
		if (v == 0) v = MOD;
		v --;
		return *this;
	}
	modnum& operator += (const modnum& o) {
		v += o.v;
		if (v >= MOD) v -= MOD;
		return *this;
	}
	modnum& operator -= (const modnum& o) {
		v -= o.v;
		if (v < 0) v += MOD;
		return *this;
	}
	modnum& operator *= (const modnum& o) {
		v = int(ll(v) * ll(o.v) % MOD);
		return *this;
	}
	modnum& operator /= (const modnum& o) {
		return *this *= o.inv();
	}

	friend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }
	friend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }
	friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }
	friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }
	friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }
	friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }
};
template <typename U, typename V> struct pairnum {
	U u;
	V v;

	pairnum() : u(0), v(0) {}
	pairnum(long long val) : u(val), v(val) {}
	pairnum(const U& u_, const V& v_) : u(u_), v(v_) {}

	friend std::ostream& operator << (std::ostream& out, const pairnum& n) { return out << '(' << n.u << ',' << ' ' << n.v << ')'; }
	friend std::istream& operator >> (std::istream& in, pairnum& n) { long long val; in >> val; n = pairnum(val); return in; }

	friend bool operator == (const pairnum& a, const pairnum& b) { return a.u == b.u && a.v == b.v; }
	friend bool operator != (const pairnum& a, const pairnum& b) { return a.u != b.u || a.v != b.v; }

	pairnum inv() const {
		return pairnum(u.inv(), v.inv());
	}
	pairnum neg() const {
		return pairnum(u.neg(), v.neg());
	}
	pairnum operator- () const {
		return pairnum(-u, -v);
	}
	pairnum operator+ () const {
		return pairnum(+u, +v);
	}

	pairnum& operator ++ () {
		++u, ++v;
		return *this;
	}
	pairnum& operator -- () {
		--u, --v;
		return *this;
	}

	pairnum& operator += (const pairnum& o) {
		u += o.u;
		v += o.v;
		return *this;
	}
	pairnum& operator -= (const pairnum& o) {
		u -= o.u;
		v -= o.v;
		return *this;
	}
	pairnum& operator *= (const pairnum& o) {
		u *= o.u;
		v *= o.v;
		return *this;
	}
	pairnum& operator /= (const pairnum& o) {
		u /= o.u;
		v /= o.v;
		return *this;
	}

	friend pairnum operator ++ (pairnum& a, int) { pairnum r = a; ++a; return r; }
	friend pairnum operator -- (pairnum& a, int) { pairnum r = a; --a; return r; }
	friend pairnum operator + (const pairnum& a, const pairnum& b) { return pairnum(a) += b; }
	friend pairnum operator - (const pairnum& a, const pairnum& b) { return pairnum(a) -= b; }
	friend pairnum operator * (const pairnum& a, const pairnum& b) { return pairnum(a) *= b; }
	friend pairnum operator / (const pairnum& a, const pairnum& b) { return pairnum(a) /= b; }
};

using mynum = pairnum<modnum<int(1e9)+7>, modnum<int(1e9)+9>>;

uint64_t toInt(mynum n) {
	auto v7 = n.u;
	auto v9 = n.v;
	v7 -= int(v9);
	v7 /= modnum<int(1e9)+7>(2);
	uint64_t r = uint64_t(int(v9)) + uint64_t(int(v7)) * uint64_t(int(1e9)+9);
	return r;
}

template <typename num> vector<vector<num>> matinv(int N, vector<vector<num>> A) {
	vector<vector<num>> res(N, vector<num>(N));
	for (int i = 0; i < N; i++) { res[i][i] = num(1); }

	for (int i = 0; i < N; i++) {
		{
			int j = i;
			while (A[j][i] == num(0)) {
				j++;
			}
			if (j > i) {
				swap(A[i], A[j]);
				swap(res[i], res[j]);
			}
		}

		num a = num(1) / A[i][i];
		for (int l = 0; l < N; l++) {
			A[i][l] *= a;
			res[i][l] *= a;
		}
		for (int j = 0; j < N; j++) {
			if (j == i) continue;
			num r = A[j][i];
			for (int l = 0; l < N; l++) {
				A[j][l] -= r * A[i][l];
				res[j][l] -= r * res[i][l];
			}
			assert(A[j][i] == num(0));
		}
	}

	return res;
}

const int MAXN = 60;
int N;
int V[MAXN][2]; // Blue and Red

int main() {
	ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> N; N--;
	for (int i = 0; i < N; i++) {
		cin >> V[i][0] >> V[i][1]; V[i][0] --, V[i][1] --;
	}

	vector<vector<mynum>> A(N, vector<mynum>(N));

	for (int i = 0; i < N; i++) {
		for (int z = 0; z < 2; z++) {
			A[i][i]++;
			if (V[i][z] < N) A[V[i][z]][i] --;
		}
	}

	vector<vector<mynum>> B = matinv(N, A);
	//for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { cerr << A[i][j] << ' '; } cerr << '\n'; } cerr << '\n';
	//for (int i = 0; i < N; i++) { for (int j = 0; j < N; j++) { cerr << B[i][j] << ' '; } cerr << '\n'; } cerr << '\n';
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			mynum tot = 0;
			for (int k = 0; k < N; k++) {
				tot += A[i][k] * B[k][j];
			}
			assert(tot == mynum(i == j));
		}
	}

	int Q; cin >> Q;
	while (Q--) {
		int v; cin >> v; v--;
		string S; cin >> S;

		vector<bool> reachable(N);
		vector<int> q;
		reachable[v] = true; q.push_back(v);
		for (int t = 0; t < int(q.size()); t++) {
			int i = q[t];
			for (int j = 0; j < N; j++) {
				if (reachable[j]) continue;
				if (V[j][S[j] == 'R'] == i) {
					reachable[j] = true;
					q.push_back(j);
				}
			}
		}
		//for (int i = 0; i < N; i++) { cerr << reachable[i] << ' '; } cerr << '\n';

		vector<mynum> f(N);

		f[0] ++;
		f[v] --;

		for (int i = 0; i < N; i++) {
			if (S[i] == 'R') {
				f[i] --;
				// red one goes extra
				if (V[i][1] < N) f[V[i][1]] ++;
			}
		}

		vector<uint64_t> y(N);
		for (int i = 0; i < N; i++) {
			mynum curVal = 0;
			for (int j = 0; j < N; j++) {
				curVal += B[i][j] * f[j];
			}
			y[i] = toInt(curVal);
		}
		//for (int i = 0; i < N; i++) { cerr << (2 * y[i] + (S[i] == 'R')) << ' '; } cerr << '\n';

		bool isGood = true;
		vector<uint64_t> realF(N);
		realF[0]++;
		realF[v]--;

		uint64_t totTime = 0;
		for (int i = 0; i < N; i++) {
			if (y[i] > (1ull<<N)) {
				isGood = false;
			}
			for (int z = 0; z < 2; z++) {
				uint64_t d = y[i] + (z && S[i] == 'R');
				if (d == 0) continue;
				//cerr << i << ' ' << z << ' ' << d << ' ' << V[i][z] << '\n';
				if (V[i][z] == N) {
					isGood = false;
					continue;
				}
				if (!reachable[V[i][z]]) {
					isGood = false;
				}
				totTime += d;
				realF[i] -= d;
				realF[V[i][z]] += d;
			}
		}

		for (int i = 0; i < N; i++) {
			if (realF[i] != 0) {
				isGood = false;
			}
		}
		//for (int i = 0; i < N; i++) { cerr << realF[i] << ' '; } cerr << '\n';

		if (!isGood) {
			cout << -1 << '\n';
		} else {
			cout << totTime << '\n';
		}
	}

	return 0;
}
