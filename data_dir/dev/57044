#pragma comment(linker, "/STACK:268435456")

#include<iostream>
#include<cstdio>

#include<string>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<deque>
#include<stack>

#include<iomanip>
#include<memory.h>
#include<algorithm>
#include<cstring>
#include<ctime>
#include<cmath>
#include<cassert>

using namespace std;

#define forn(i, n) for(int i = 0; i < (int)(n); ++i)
#define for1(i, n) for(int i = 1; i < (int)(n); ++i)
#define forr(i, n) for(int i = int(n) - 1; i >= 0; --i)
#define fore(i, a, b) for(int i = int(a); i <= int(b); ++i)
#define correct(x, y, n, m) (0 <= x && x < n && 0 <= y && y < m)
#define X first
#define Y second
#define all(a) a.begin(), a.end()
#define pb push_back
#define mp make_pair
#define sz(v) (int)(v.size())
#define hash archash
#define next arcnext
#define link arclink
#define y0 arcy0
#define y1 arcy1
#define log2 arclog2

template<typename T> inline T abs(T a){ return ((a < 0) ? -a : a); }
template<typename T> inline T sqr(T a){ return a * a; }
template<class T> T gcd(T a, T b) { return a ? gcd (b % a, a) : b; }
template<class T> T lcm(T a, T b) { return a / gcd (a, b) * b; }
template<class T> T sign(T a) { return a > 0 ? 1 : (a < 0 ? -1 : 0); }

typedef long long li;
typedef unsigned long long uli;
typedef long double ld;
typedef pair <li, li> pt;
typedef vector <int> vi; 
typedef vector <vector <int> > vvi;
typedef vector <pair <int, int> > vpt; 

const int dx[] = {-1, 0, 1,  0};
const int dy[] = { 0, 1, 0, -1};
const int dxK[] = {-1, -1, 0, 1, 1,  1,  0, -1};
const int dyK[] = { 0,  1, 1, 1, 0, -1, -1, -1};
const int dxKn[] = {-2, -1, 1, 2,  2,  1, -1, -2};
const int dyKn[] = { 1,  2, 2, 1, -1, -2, -2, -1};

const int N = int(4e5) + 9;
const int M = int(3e3) + 9;
const int LOGN = 22;
const int SQN = 350;
const int MOD = int(1e9) + 7;
const int INF = 1e9 + 100;
const li INF64 = 2e18;
const ld PI = 3.1415926535897932384626433832795;
const ld EPS = 1e-9;

vector <pt > g[N];
li pw[N];
int tin[N], tout[N], timer;
int up[N][LOGN];
int nxt[N];
pt edge[N];

bool upper(int a, int b){
	return tin[a] <= tin[b] && tout[a] >= tout[b];
}

int lca(int a, int b){
	if(upper(a, b))
		return a;
	if(upper(b, a))
		return b;
	forr(i, LOGN)
		if(!upper(up[a][i], b))
			a = up[a][i];
	return up[a][0];
}

int getNxt(int x){
	if(nxt[x] == 0)
		return 0;
	if(pw[nxt[x]] == 1)
		nxt[x] = getNxt(up[nxt[x]][0]);
	return nxt[x];
}

void dfs(int v, int p){
	tin[v] = timer++;
	nxt[v] = v;

	up[v][0] = p;
	for1(i, LOGN)
		up[v][i] = up[up[v][i - 1]][i - 1];

	forn(i, sz(g[v])){
		int to = g[v][i].X;
		if(to != p){
			dfs(to, v);
			pw[to] = g[v][i].Y;
		}
	}
	
	

	tout[v] = timer++;
}

li get2(int x, int p, li w){
	while(x != p){
		if(w == 0)
			return w;
		int nxtx = getNxt(x);
		if(upper(nxtx, p))
			return w;
		x = nxtx;
		w /= pw[x];
		assert(pw[x] > 1);
		x = up[x][0];
	}
	return w;
}

li get(int x, int y, li w){
	int p = lca(x, y);
	w = get2(x, p, w);
	w = get2(y, p, w);
	return w;
}

void solve(){
	int n, m;
	cin >> n >> m;
	//scanf("%d %d", &n, &m);
	forn(i, n - 1){
		int x, y;
		li w;
		cin >> x >> y >> w;
		//scanf("%d %d %I64d", &x, &y, &w);
		--x, --y;
		edge[i] = mp(x, y);
		g[x].pb(mp(y, w));
		g[y].pb(mp(x, w));
	}

	dfs(0, 0);
	forn(i, m){
		int t;
		cin >> t;
		//scanf("%d", &t);
		if(t == 1){
			int x, y;
			li w;
			cin >> x >> y >> w;
			//scanf("%d %d %I64d", &x, &y, &w);
			--x, --y;
			//printf("%I64d\n", get(x, y, w));
			cout << get(x, y, w) << endl;
		}
		else{
			int num;
			li w;
			//scanf("%d %I64d", &num, &w);
			cin >> num >> w;
			--num;
			int x = edge[num].X, y = edge[num].Y;
			if(upper(y, x))
				swap(x, y);
			assert(pw[y] > w);
			pw[y] = w;
		}
	}	
}

int main(){

	///freopen("input.txt", "r", stdin);
	///freopen("output.txt", "w", stdout);

	srand(time(NULL));
	cout << setprecision(10) << fixed;
	cerr << setprecision(10) << fixed;   

	solve();

	return 0;
}