#include <bits/stdc++.h>
using namespace std;
/***********************************************/
/* Dear online judge:
 * I've read the problem, and tried to solve it.
 * Even if you don't accept my solution, you should respect my effort.
 * I hope my code compiles and gets accepted.
 *  ___  __     _______    _______      
 * |\  \|\  \  |\  ___ \  |\  ___ \     
 * \ \  \/  /|_\ \   __/| \ \   __/|    
 *  \ \   ___  \\ \  \_|/__\ \  \_|/__  
 *   \ \  \\ \  \\ \  \_|\ \\ \  \_|\ \ 
 *    \ \__\\ \__\\ \_______\\ \_______\
 *     \|__| \|__| \|_______| \|_______|
 */
const long long mod = 1000000007;

typedef vector<int> VI;
typedef vector<VI> VVI;
typedef long long L;
typedef vector<L> VL;
typedef vector<VL> VVL;
typedef pair<int, int> PII;
typedef vector<PII> VPII;

const L INF = numeric_limits<L>::max() / 4;

struct MinCostMaxFlow {
	int N;
	VVL cap, flow, cost;
	VI found;
	VL dist, pi, width;
	VPII dad;

	MinCostMaxFlow(int N) : 
		N(N), cap(N, VL(N)), flow(N, VL(N)), cost(N, VL(N)), 
		found(N), dist(N), pi(N), width(N), dad(N) {}

	void AddEdge(int from, int to, L cap, L cost) {
		this->cap[from][to] = cap;
		this->cost[from][to] = cost;
	}

	void Relax(int s, int k, L cap, L cost, int dir) {
		L val = dist[s] + pi[s] - pi[k] + cost;
		if (cap && val < dist[k]) {
			dist[k] = val;
			dad[k] = make_pair(s, dir);
			width[k] = min(cap, width[s]);
		}
	}

	L Dijkstra(int s, int t) {
		fill(found.begin(), found.end(), false);
		fill(dist.begin(), dist.end(), INF);
		fill(width.begin(), width.end(), 0);
		dist[s] = 0;
		width[s] = INF;

		while (s != -1) {
			int best = -1;
			found[s] = true;
			for (int k = 0; k < N; k++) {
				if (found[k]) continue;
				Relax(s, k, cap[s][k] - flow[s][k], cost[s][k], 1);
				Relax(s, k, flow[k][s], -cost[k][s], -1);
				if (best == -1 || dist[k] < dist[best]) best = k;
			}
			s = best;
		}

		for (int k = 0; k < N; k++)
			pi[k] = min(pi[k] + dist[k], INF);
		return width[t];
	}

	pair<L, L> GetMaxFlow(int s, int t) {
		L totflow = 0, totcost = 0;
		while (L amt = Dijkstra(s, t)) {
			totflow += amt;
			for (int x = t; x != s; x = dad[x].first) {
				if (dad[x].second == 1) {
					flow[dad[x].first][x] += amt;
					totcost += amt * cost[dad[x].first][x];
				} else {
					flow[x][dad[x].first] -= amt;
					totcost -= amt * cost[x][dad[x].first];
				}
			}
		}
		return make_pair(totflow, totcost);
	}
};

int cnt[30];
void get(string & s) {
	memset(cnt,0,sizeof cnt);
	for(auto c : s) {
		cnt[c - 'a']++;
	}
}

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);

	string t;
	int N;
	cin>>t>>N;
	MinCostMaxFlow mcmf(N+26+2);
	get(t);
	for(int i = 0;i < 26;i++) {
		if(cnt[i])
			mcmf.AddEdge(N+i,N+26+1,cnt[i],0);
	}
	vector<string> s(N);
	vector<int> a(N);
	for(int i = 0;i < N;i++) {
		cin>>s[i]>>a[i];
		get(s[i]);
		mcmf.AddEdge(N+26,i,min(a[i],(int)s[i].size()),0);
		for(int j = 0;j < 26;j++) {
			if(cnt[j])
				mcmf.AddEdge(i,N+j,cnt[j],i+1);
		}
	}
	pair<int,int> cf = mcmf.GetMaxFlow(N+26,N+26+1);
	if(cf.first != (int)t.size()) {
		cout<<"-1\n";
		return 0;
	}
	cout<<cf.second<<'\n';
	return 0;
}
