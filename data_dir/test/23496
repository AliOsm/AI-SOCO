/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author Alex
 */

/*
I am but a farce, a satire of stability
Insecurity is an uphill struggle, it's me versus the world
The shore still starves,
For another,

Novel of my shipwrecked being tied up dried alive still breathing
The sands of time, from me are running out,
my hands shake, in apprehension,
Of every action I'm guilty of playing the victim,
The shore still starves,
For another,

Novel of my shipwrecked being tied up dried alive still breathing
The sands of time, for me are running out.

Just like the embrace of arms that made you
They'll surely destroy you.
Just like the embrace of arms that made you
They'll surely destroy you.

It's time for your panic,
Then it kills and makes, you manic,

Making its way inside - relax, it's alright,
Making its way inside - relax, it's alright
Panic grips your frantic breathing
I can't breathe, I can't breathe,i cant breathe!

Just like the embrace of arms that made you
They'll surely destroy you.
Just like the embrace of arms that made you
They'll surely destroy you.

Just like the embrace of arms that made you
They'll surely destroy you.
Just like the embrace of arms that made you
They'll surely destroy you.
*/
#include <fstream>

#include <math.h>
#include <iostream>
using namespace std;



#include <fstream>


#include <vector>


#include <iterator>

#include <string>
#include <stdexcept>
#ifdef SPCPPL_DEBUG
	#define SPCPPL_ASSERT(condition) \
	if(!(condition)) { \
		throw std::runtime_error(std::string() + #condition + " in line " + std::to_string(__LINE__) + " in " + __PRETTY_FUNCTION__); \
	}
#else
#define SPCPPL_ASSERT(condition)
#endif





/**
* Support decrementing and multi-passing, but not declared bidirectional(or even forward) because
* it's reference type is not a reference.
*
* It doesn't return reference because
* 1. Anyway it'll not satisfy requirement [forward.iterators]/6
*   If a and b are both dereferenceable, then a == b if and only if *a and
*   b are bound to the same object.
* 2. It'll not work with reverse_iterator that returns operator * of temporary which is temporary for this iterator
*
* Note, reverse_iterator is not guaranteed to work  now too since it works only with bidirectional iterators,
* but it's seems to work at least on my implementation.
*
* It's not really useful anywhere except iterating anyway.
*/
template <typename T>
class IntegerIterator : public std::iterator<std::input_iterator_tag, T, std::ptrdiff_t, T*, T> {
public:
    explicit IntegerIterator(int value): value(value) {

    }

    IntegerIterator& operator++ () {
        ++value;
        return *this;
    }

    IntegerIterator operator++ (int) {
        IntegerIterator copy = *this;
        ++value;
        return copy;
    }

    IntegerIterator& operator-- () {
        --value;
        return *this;
    }

    IntegerIterator operator-- (int) {
        IntegerIterator copy = *this;
        --value;
        return copy;
    }

    T operator * () const {
        return value;
    }

    bool operator == (IntegerIterator rhs) {
        return value == rhs.value;
    }

    bool operator != (IntegerIterator rhs) {
        return !(*this == rhs);
    }
private:
    T value;
};

template <typename T>
class IntegerRange {
public:
    IntegerRange(T begin, T end): begin_(begin), end_(end) {

    }

    IntegerIterator<T> begin() const {
        return IntegerIterator<T>(begin_);
    }

    IntegerIterator<T> end() const {
        return IntegerIterator<T>(end_);
    }

private:
    T begin_;
    T end_;
};

template <typename T>
class ReversedIntegerRange {
    typedef std::reverse_iterator<IntegerIterator<T>> IteratorType;
public:
    ReversedIntegerRange(T begin, T end): begin_(begin), end_(end) {

    }

    IteratorType begin() const {
        return IteratorType(IntegerIterator<T>(begin_));
    }

    IteratorType end() const {
        return IteratorType(IntegerIterator<T>(end_));
    }

private:
    T begin_;
    T end_;
};

template <typename T>
IntegerRange<T> range(T to) {
    SPCPPL_ASSERT(to >= 0);
    return IntegerRange<T>(0, to);
}

template <typename T>
IntegerRange<T> range(T from, T to) {
    SPCPPL_ASSERT(from <= to);
    return IntegerRange<T>(from, to);
}

template <typename T>
ReversedIntegerRange<T> downrange(T from) {
    SPCPPL_ASSERT(from >= 0);
    return ReversedIntegerRange<T>(from, 0);
}

template <typename T>
ReversedIntegerRange<T> downrange(T from, T to) {
    SPCPPL_ASSERT(from >= to);
    return ReversedIntegerRange<T>(from, to);
}


#include <algorithm>


template<typename R>
void sort(R &range) {
    std::sort(range.begin(), range.end());
}

template<typename R, typename Comp>
void sort(R &range, Comp comp) {
    std::sort(range.begin(), range.end(), comp);
}

template<typename R>
void reverse(R &range) {
    std::reverse(range.begin(), range.end());
}

template<typename R, typename T>
auto lower_bound(const R &range, const T &value) -> decltype(range.begin()) {
    return std::lower_bound(range.begin(), range.end(), value);
}

template<typename R, typename T, typename Comp>
auto lower_bound(const R &range, const T &value, Comp comp) -> decltype(range.begin()) {
    return std::lower_bound(range.begin(), range.end(), value, comp);
}

template<typename R, typename T>
auto upper_bound(const R &range, const T &value) -> decltype(range.begin()) {
    return std::upper_bound(range.begin(), range.end(), value);
}

template<typename R, typename T, typename Comp>
auto upper_bound(const R &range, const T &value, Comp comp) -> decltype(range.begin()) {
    return std::upper_bound(range.begin(), range.end(), value, comp);
}

template <typename R>
auto unique(R& range) -> decltype(range.begin()) {
    return std::unique(range.begin(), range.end());
}

template <typename R>
auto min_element(const R& range) -> decltype(range.begin()) {
    return std::min_element(range.begin(), range.end());
}

template <typename R>
auto max_element(const R& range) -> decltype(range.begin()) {
    return std::max_element(range.begin(), range.end());
}

template <typename R>
bool next_permutation(R& range) {
    return std::next_permutation(range.begin(), range.end());
}

template <typename R>
R sorted(R range) {
    sort(range);
    return range;
}

template <typename R, typename Comp>
R sorted(R range, Comp comp) {
    sort(range, comp);
    return range;
}

template <typename R>
R reversed(R range) {
    reverse(range);
    return range;
}

template <typename T>
T modpow(T base, T exp, T modulus) {
    base %= modulus;
    T result = 1;
    while (exp > 0) {
        if (exp & 1) result = (result * base) % modulus;
        base = (base * base) % modulus;
        exp >>= 1;
    }
    return result;
}

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define for1(i, n) for (int i = 1; i <= int(n); i++)
#define forv(i, v) forn(i, v.size())

#define all(x) x.begin(), x.end()
#define pb push_back
#define mp make_pair
#define el "\n";
typedef long double ld;
typedef long long ll;
typedef pair<int, int> pii;

#define llmin -9223372036854775807







//SWISTAKKK





#define MP make_pair
#define PB push_back
#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)
#define RE(i, n) FOR(i, 1, n)
#define FORD(i, a, b) for(int i = (a); i >= (b); --i)
#define REP(i, n) for(int i = 0;i <(n); ++i)
#define VAR(v, i) __typeof(i) v=(i)
#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)
#define ALL(x) (x).begin(), (x).end()
#define SZ(x) ((int)(x).size())
#ifdef LOCAL
#define debug(x) {cerr <<#x<<" = " <<x<<"\n"; }
#define debug2(x, y) {cerr <<#x<<" = " <<x<<", "<<#y <<" = " <<y <<"\n";}
#define debug3(x, y, z) {cerr <<#x<<" = " <<x<<", "<<#y <<" = " <<y <<", "<<#z<<" = "<<z<<"\n";}
#define debug4(x, y, z, t) {cerr <<#x<<" = " <<x<<", "<<#y <<" = " <<y <<", "<<#z<<" = "<<z<<", "<<#t <<" = " <<t<<"\n";}
#define debugv(x) {{cerr <<#x <<" = "; FORE(itt, (x)) cerr <<*itt <<", "; cerr <<"\n"; }}
#else
#define debug(x)
#define debug2(x, y)
#define debug3(x, y, z)
#define debug4(x,y,z,t)
#define debugv(x)
#endif
#define make(type, x) type x; in>>x;
#define make2(type, x, y) type x, y; in>>x>>y;
#define make3(type, x, y, z) type x, y, z; in>>x>>y>>z;
#define make4(type, x, y, z, t) type x, y, z, t; in>>x>>y>>z>>t;
using namespace std;
typedef long long ll;
typedef long double LD;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
typedef vector<ll> VI;
typedef vector<VI> VVI;
typedef vector<ll> VLL;
typedef vector<pair<int, int> > VPII;
typedef vector<pair<ll, ll> > VPLL;

template<class C> void mini(C&a4, C b4){a4=min(a4, b4); }
template<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }
template<class T1, class T2>
ostream& operator<< (ostream &out, std::pair<T1, T2> pair) { return out << "(" << pair.first << ", " << pair.second << ")";}
template<class A, class B, class C> struct Triple { A first; B second; C third; };
template<class T> void ResizeVec(T&, vector<int>) {}
template<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {
    vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }
    for (T& v : vec) { ResizeVec(v, sz); }
}

///MARATSNOWBEAAR


template<typename T> inline void minimize(T &a, T b) { a = std::min(a, b); }
template<typename T> inline void maximize(T &a, T b) { a = std::max(a, b); }

template<typename T> struct argument_type;
template<typename T, typename U> struct argument_type<T(U)> { typedef U type; };



template <typename T1, typename T2> istream& operator >>(istream& is, pair<T1, T2>& s) { is >> s.first >> s.second; return is; }
template <typename T> ostream& operator << (ostream& os, const vector<T> &v) { for (int i = 0 ; i < v.size() ; i++) os << v[i] << ' '; os << endl; return os; }
template <typename T1, typename T2> ostream& operator <<(ostream& s, pair<T1, T2>& t) { s << t.first << ' ' << t.second; return s; }
template <typename T> vector<T> readVector(std::istream& in, int n) {
    vector<T> res(n);
    for (int i = 0 ; i < n ; i++) in >> res[i];
    return res;
}











using namespace std;
class TaskC {
public:
    struct target{
        int x, y, t;
        double p;
    };
    static bool sorter(target& a, target& b){return a.t < b.t;}
    void solve(std::istream& in, std::ostream& out) {
        make(int, n);
        vector<target> targets;
        forn(i, n){
            make3(int, x, y, t);
            make(double, p);
            target temp;
            temp.x = x;
            temp.y = y;
            temp.t = t;
            temp.p = p;
            targets.push_back(temp);
        }
        sort(targets.begin(), targets.end(), sorter);
        vector<vector<double>> mem(n + 1, vector<double>(n + 2, - 2));
        out << dp(0, - 1, targets, mem) << el;
	}
    double dp(int index, int previndex, vector<target> & targets, vector<vector<double>> & mem){
        if (index == targets.size()) return 0;
        if (mem[index][previndex + 1] > -1) return mem[index][previndex + 1];
        int x = targets[previndex].x, y = targets[previndex].y;
        double distance = previndex == -1 ? 0 : sqrt((x - targets[index].x) * (x - targets[index].x) + (y - targets[index].y) * (y - targets[index].y));
        double dont = dp(index + 1, previndex, targets, mem);
        double take = (previndex == -1 || distance <= targets[index].t - targets[previndex].t) ? (targets[index].p + dp(index + 1, index, targets, mem)) : 0;
        return mem[index][previndex + 1] = max(dont, take);
    }
};


int main() {
	std::cin.sync_with_stdio(false);
	std::cin.tie(0);
	std::cout << std::fixed;
	std::cout.precision(20);
	TaskC solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
