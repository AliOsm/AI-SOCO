/*
    In the name of
        "ALLAH"
    And say "AL-HAMD-U-LILLAH"
    |
*/

#include<bits/stdc++.h>
#define   ll   long long
#define   llu  unsigned long long
#define   _    printf("\n")
int      take() {
    int n;
    scanf("%d",&n);
    return n;

}
double  ttake() {
    double n;
    scanf("%lf",&n);
    return n;
}
ll     takes() {
    ll n;
    scanf("%lld",&n);
    return n;

}

#define  Int             take()
#define  Dnt             ttake()
#define  LL              takes()
#define  done            {return 0;}
#define  fr(i,x,n,a)     for(int i=x;i<=n;i+=a)
#define  FR(a,b,x)       for(int i=(a);i<=(b);i+=(x))
#define  rfr(i,x,n,a)    for(int i=x;i>=n;i--)
int      cas;
#define  print           printf("Case %d:",++cas)
#define  vi              vector<int>
#define  vs              vector<string>
#define  vl              vector<ll>
#define  pb              push_back
#define  pii             pair<int,int>
#define  vii             vector<pii>
#define  pll             pair<ll,ll>
#define  pil             pair<int,ll>
#define  pli             pair<ll,int>
#define  pipii           pair<int,pii>
#define  piipi           pair<pii,int>
#define  mk              make_pair
#define  fill(x,v)       memset(x,v,sizeof x)

using    namespace       std;

bool     approximatelyEqual(float a, float b, float epsilon) {
    return fabs(a - b) <= ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}

bool     essentiallyEqual(float a, float b, float epsilon) {
    return fabs(a - b) <= ( (fabs(a) > fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}

bool     definitelyGreaterThan(float a, float b, float epsilon) {
    return (a - b) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}

bool     definitelyLessThan(float a, float b, float epsilon) {
    return (b - a) > ( (fabs(a) < fabs(b) ? fabs(b) : fabs(a)) * epsilon);
}
#define  Info             struct info
#define  dbg(x)          {cout<<"ekhane"<<x<<endl;}
#define  SS              second
#define  FF              first
#define  PQ              priority_queue
#define  great           greater
#define  less            lesser
#define  mii             map<int,int>
#define  mil             map<int,ll>
#define  mli             map<ll,int>
#define  mll             map<ll,ll>
#define  msb             map<string,bool>
#define  V               vector
#define  M               200005
#define  pf              printf
#define  inf             INT_MAX
#define  sz( x )         ( int )x.size()
//////////////////////////////////////////
bool g[ 1005 ][ 1005 ][ 2 ] ;
int f[ 1005 ][ 1005 ][ 2 ] , id ;
void step( int x , int y ){
    if( x < 1 || y < 1 ) return ;
    if( x == 1 && y == 1 ) return ;
    if( g[ x ][ y ][ id ] ){
        step( x - 1 , y ) ;
        pf("D") ;
    }else{
        step( x , y - 1 ) ;
        pf("R") ;
    }
}
int main(){
    int tc = 1 ;
    while( tc-- ){
        int n = Int , gotZero = 0 ;
        fr( i , 2 , n , 1 ) f[ 0 ][ i ][ 0 ] = inf , f[ 0 ][ i ][ 1 ] = inf , f[ i ][ 0 ][ 0 ] = f[ i ][ 0 ][ 1 ] = inf ;
        fr( i , 1 , n , 1 ){
            fr( k , 1 , n , 1 ){
                int u = Int ;
                if( !u ) gotZero = i ;
                else{
                    int two = u ;
                    while( two % 2 == 0 ) f[ i ][ k ][ 0 ]++ , two /= 2 ; two = u ;
                    while( two % 5 == 0 ) f[ i ][ k ][ 1 ]++ , two /= 5 ;
                }
              fr( j , 0 , 1 , 1 ){
                if( f[ i - 1 ][ k ][ j ] < f[ i ][ k - 1 ][  j ] ){
                    g[ i ][ k ][ j ] = 1 ;
                    f[ i ][ k ][ j ] += f[ i - 1 ][ k ][ j ] ;
                }else{
                      f[ i ][ k ][ j ] += f[ i ][ k - 1 ][ j ] ;
                }
              }
            }
        }
      id = f[ n ][ n ][ 1 ] < f[ n ][ n ][ 0 ] ;
      if( gotZero and min( f[ n ][ n ][ 1 ] , f[ n ][ n ][ 0 ] ) > 1 ){
        pf("1\n") ;
        fr( i , 2 , gotZero , 1 ) pf("D") ;
        fr( i , 2 , n , 1 ) pf("R") ;
        fr( i , gotZero + 1 , n , 1 ) pf("D") ;
      }else{
        pf("%d\n",min( f[ n ][ n ][ 1 ] , f[ n ][ n ][ 0 ] ) ) ;
        step( n , n ) ;
      }
    }
 done ;
}
