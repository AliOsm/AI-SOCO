#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace __gnu_pbds;
using namespace std;


#define fast ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)
#define PSET(x,y) fixed<<setprecision(y)<<x
#define pb push_back
#define pii pair<int,int>
#define pf push_front
#define mp make_pair
#define vi vector<int>
#define vip vector<pair<int,int> >
#define ff first
#define ss second
#define int long long
#define mod 1000000007
#define BIG 998244353
#define s(t) scanf("%lld",&t)
#define p(t) printf("%lld\n",t)
#define mii map<int,int>
#define MSET(table,i) memset(table, i, sizeof(table))
#define endl '\n'
#define tc int t;cin>>t;while(t--)
#define pi  3.1415926358
#define bits(x) __builtin_popcount(x)
#define minimum(a,n) min_element(a,a+n)-a
#define maximum(a,n) max_element(a,a+n)-a
#define pqbig priority_queue<pii>
#define pqsmall priority_queue<int,vector<int>,greater<int> >
#define all(v) v.begin(),v.end()
#define sitr set<int>:: iterator
#define spitr set<pii>:: iterator
#define mitr map<int,int>:: iterator

int toint(const string &s) {stringstream ss; ss << s; int x; ss >> x; return x;}
string tostring ( int number ) {stringstream ss; ss << number; return ss.str();}


typedef tree<int, null_type, less<int>, rb_tree_tag,
        tree_order_statistics_node_update>
        new_data_set;


#define trace1(x)                cerr<<#x<<": "<<x<<endl
#define trace2(x, y)             cerr<<#x<<": "<<x<<" | "<<#y<<": "<<y<<endl
#define trace3(x, y, z)          cerr<<#x<<":" <<x<<" | "<<#y<<": "<<y<<" | "<<#z<<": "<<z<<endl
#define trace4(a, b, c, d)       cerr<<#a<<": "<<a<<" | "<<#b<<": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<endl
#define trace5(a, b, c, d, e)    cerr<<#a<<": "<<a<<" | "<<#b<<": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<" | "<<#e<< ": "<<e<<endl
#define trace6(a, b, c, d, e, f) cerr<<#a<<": "<<a<<" | "<<#b<<": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<" | "<<#e<< ": "<<e<<" | "<<#f<<": "<<f<<endl

const int N=2e5+5;
int parent[N][20];
vi adj[N];
int depth[N];
int n,m;

void dfs(int node,int pt,int lvl)
{
	parent[node][0]=pt;
	depth[node]=lvl;
	for(int i=0;i<adj[node].size();i++)
	{
		int el=adj[node][i];
		if(el!=pt)
			dfs(el,node,lvl+1);
	}
}

void solve()
{
	for(int i=1;i<20;i++)
	{
		for(int j=1;j<=n;j++)
			parent[j][i]=parent[parent[j][i-1]][i-1];
	}
}

int query(int u, int v) 
{ 
    if (depth[v] < depth[u]) 
        swap(u, v); 
  
    int diff = depth[v] - depth[u]; 
  
    for (int i=0; i<20; i++) 
        if ((diff>>i)&1) 
            v = parent[v][i]; 
  
    if (u == v) 
        return u; 
  
    for (int i=19; i>=0; i--) 
        if (parent[u][i] != parent[v][i]) 
        { 
            u = parent[u][i]; 
            v = parent[v][i]; 
        } 
  
    return parent[u][0]; 
} 

int32_t main()
{
	fast;
	cin>>n>>m;
	for(int i=1;i<n;i++)
	{
		int x,y;cin>>x>>y;
		adj[x].pb(y);
		adj[y].pb(x);
	}
	dfs(1,0,0);
	solve();
	while(m--)
	{
		int k;cin>>k;
		vi v(k);
		int max_dp=-1;
		int nd=-1;
		for(int i=0;i<k;i++)
		{
			cin>>v[i];
			if(depth[v[i]]>max_dp)
				max_dp=depth[v[i]],nd=v[i];
		}
		bool flag=true;
		for(int i=0;i<k;i++)
		{
			int lca=query(v[i],nd);
			int dis=depth[nd]+depth[v[i]]-2*depth[lca];
			if(dis!=(max_dp-depth[v[i]]) and dis!=(max_dp-depth[lca]+1))
				flag=false;
		}
		if(flag)
			cout<<"YES"<<endl;
		else
			cout<<"NO"<<endl;
	}
}
