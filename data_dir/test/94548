/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <bits/stdc++.h>

using namespace std;

class TaskB {
public:
    void solve(istream& in, ostream& out) {
        int n, m, r, c, x, y;
        in >> n >> m >> r >> c >> x >> y;
        --r;
        --c;
        vector<string> sg(n);
        for (int i = 0; i < n; ++i) {
            in >> sg[i];
        }
        /*x = y = 1'000'000'000;
        n = m = 2000;
        sg.resize(2000);
        for (int i = 0; i < n; ++i) {
            sg[i] = string(2000, '.');
        }*/
        vector<vector<int>> g(n, vector<int>(m));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                g[i][j] = (sg[i][j] == '.');
            }
        }
        vector<vector<pair<int, int>>> res(n, vector<pair<int, int>>(m, {-1, -1}));
        priority_queue<tuple<int, int, int, int>> pq;
        pq.emplace(x, y, r, c);
        while (!pq.empty()) {
            auto [lx, ly, a, b] = pq.top();
            pq.pop();
            res[a][b] = {lx, ly};
            for (auto [da, db] : vector<pair<int, int>>{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {
                int na = a + da, nb = b + db;
                if (na >= 0 && na < n && nb >= 0 && nb < m && g[na][nb]) {
                    int nlx = lx - (db == -1), nly = ly - (db == 1);
                    if (nlx >= 0 && nly >= 0 && pair(nlx, nly) > res[na][nb]) {
                        pq.emplace(nlx, nly, na, nb);
                        res[na][nb] = pair(nlx, nly);
                    }
                }
            }
        }
        vector<vector<pair<int, int>>> res2(n, vector<pair<int, int>>(m, {-1, -1}));
        pq.emplace(y, x, r, c);
        /*for (int a = 0; a < n; ++a) {
            for (int b = 0; b < m; ++b) {
                if (res[a][b] != pair(-1, -1)) {
                    pq.emplace(res[a][b].second, res[a][b].first, a, b);
                    res2[a][b] = {res[a][b].second, res[a][b].first};
                }
            }
        }*/
        while (!pq.empty()) {
            auto [ly, lx, a, b] = pq.top();
            pq.pop();
            res2[a][b] = {ly, lx};
            for (auto [da, db] : vector<pair<int, int>>{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}) {
                int na = a + da, nb = b + db;
                if (na >= 0 && na < n && nb >= 0 && nb < m && g[na][nb]) {
                    int nlx = lx - (db == -1), nly = ly - (db == 1);
                    if (nlx >= 0 && nly >= 0 && pair(nly, nlx) > res2[na][nb]) {
                        pq.emplace(nly, nlx, na, nb);
                        res2[na][nb] = {nly, nlx};
                    }
                }
            }
        }
        int ans = 0;
        for (int a = 0; a < n; ++a) {
            for (int b = 0; b < m; ++b) {
                ans += res2[a][b] != pair(-1, -1);
            }
        }
        out << ans << "\n";
    }
};

int main() {
	std::ios::sync_with_stdio(false); cin.tie(nullptr);
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
