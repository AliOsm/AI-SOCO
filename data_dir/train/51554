/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author HARSHAD
 */

#include <bits/stdc++.h>
using namespace std;

#define int long long
#define f(i,n) for(int i=0;i<n;i++)
#define rep(i,a,b) for(int i=a;i<=b;i++)

const int MOD = 1e9+7;
const int N = 3e5+5;

inline int add(int x, int y){
	return (x+y)%MOD;
}
inline int mul(int x, int y){
	return x*y%MOD;
}


vector<int> adj[N];

/*
class segmentTree{
public:
	int n;
	vector<int> tree, lazy, arr;
	segmentTree(int n){
		this->n = ++n;
		tree = vector<int>(4*n + 5, 0);
		lazy = vector<int>(4*n + 5, 0);
	}
	int query(int node, int start, int end, int l, int r){
		if(lazy[node]){
			tree[node] = add(tree[node], mul(end-start+1, lazy[node]));
			if(start != end){
				lazy[2*node] = add(lazy[2*node], lazy[node]);
				lazy[2*node + 1] = add(lazy[2*node + 1], lazy[node]);
			}
			lazy[node] = 0;
		}
		if(start>end or end<l or start>r) return 0;
		if(start >=l and end <= r) return tree[node];
		int mid = (start + end) >> 1;
		return add(query(2*node, start, mid, l, r), query(2*node + 1, mid + 1, end, l, r));
	}
	void update(int node, int start, int end, int l, int r, int val){
		if(lazy[node]){
			tree[node] = add(tree[node], mul(end-start+1, lazy[node]));
			if(start != end){
				lazy[2*node] = add(lazy[2*node], lazy[node]);
				lazy[2*node + 1] = add(lazy[2*node + 1], lazy[node]);
			}
			lazy[node] = 0;
		}
		if(start > end or end < l or start > r) return;
		if(start >= l and end <= r){
			tree[node] = add(tree[node], mul(end-start+1, val));
			if(start != end){
				lazy[2*node] = add(lazy[2*node], val);
				lazy[2*node + 1] = add(lazy[2*node + 1], val);
			}
			return;
		}
		int mid = (start + end) >> 1;
		update(2*node, start, mid, l, r, val);
		update(2*node+1, mid + 1, end, l, r, val);
		tree[node] = add(tree[2*node], tree[2*node + 1]);
	}
	void updateUtil(int l, int r, int val){
		update(1, 1, n, l, r, val);
	}
	int queryUtil(int l, int r){
		return query(1, 1, n, l, r);
	}
};
*/

int start[N], finish[N], T, level[N], x, y, z, t, n, m, F[N], F2[N];


int query(int x){
	int sum = 0;
	for(;x && x < N;x += x & -x) sum = (sum + F[x]) % MOD;
	return sum;
}

int query2(int x){
	int sum = 0;
	for(;x && x < N;x += x & -x) sum = (sum + F2[x]) % MOD;
	return sum;
}

void update(int x,int y,int t){
	int sum = 0; x--;
	for(; y>0 ; y -= y & -y) F[y] = (F[y] + t + 5*MOD) % MOD;
	for(; x>0 ; x -= x & -x) F[x] = (F[x] - t + 5*MOD) % MOD;
}

void update2(int x,int y,int t){
	int sum = 0; x--;
	for(; x>0 ; x -= x & -x) F2[x] = (F2[x] - t + 5*MOD) % MOD;
	for(; y>0 ; y -= y & -y) F2[y] = (F2[y] + t + 5*MOD) % MOD;
}

class EOnChangingTree {
public:
	int time;
	void dfs(int u, int parent, int lvl){
		level[u] = lvl;
		start[u] = ++time;
		for(int v: adj[u]){
			if(v == parent) continue;
			dfs(v, u, 1+lvl);
		}
		finish[u] = time;
	}

	void solve(std::istream& in, std::ostream& out) {
		in >> n;
		rep(u, 2, n){
			int v; in >> v;
			adj[u].push_back(v);
			adj[v].push_back(u);
		}
		time = 0;
		level[0] = 0;
		dfs(1, 0, 1);

		int q; in >> q;
		while(q--){
			int t; in >> t;
			if(t==1){
				int v, x, k; in >> v >> x >> k;
				int l = start[v], r = finish[v];
				int g = level[v];
				update(l, r, add(x, mul(level[v], k)));
				update2(l, r, k);
			}
			else{
				int v; in >> v;
				int l = start[v];
				int res = query(l) - mul(query2(l), level[v]) + MOD;
				res %= MOD;
				out << res << '\n';
			}
		}

	}
};


int32_t main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
	EOnChangingTree solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
