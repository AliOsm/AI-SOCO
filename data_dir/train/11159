/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author /dev/null
 */

#include <bits/stdc++.h>
#include <ext/pb_ds/tree_policy.hpp>
#include <ext/pb_ds/assoc_container.hpp>

using namespace std;
using namespace __gnu_pbds;

template <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;

typedef long long ll;
typedef long double ld;
typedef pair<ll, ll> pll;
typedef pair<double, double> pdd;

#define all(x)                      (x).begin(),(x).end()
#define Sort(x)                     sort(all((x)))
#define X                           first
#define Y                           second
#define Mp                          make_pair
#define sep                         ' '
#define endl                        '\n'
#define debug(x)                    cerr << #x << " = " << x << endl
#define SZ(x)                       ll(x.size())
#define fast_io                     ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
#define set_random                  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());

ll poww(ll a, ll b, ll md) {
    return (!b ? 1 : (b & 1 ? a * poww(a * a % md, b / 2, md) % md : poww(a * a % md, b / 2, md) % md));
}

set_random;

const ll MAXN = 1e5 + 10;
const ll LOG = 20;
const ll INF = 1e9;
const ll MOD = 1e9 + 7; // 998244353; // 1e9 + 9;

template <ll SIZE>
struct DSU {
    ll par[SIZE] , sz[SIZE];
    DSU(){
        fill(par , par + SIZE , -1);
        fill(sz , sz + SIZE , 1);
    }

    ll Find(ll v){
        return (par[v] == -1 ? v : par[v] = Find(par[v]));
    }

    ll Union(ll v , ll u){
        ll pv = Find(v) , pu = Find(u);
        if(pv == pu)    return 0;
        if(sz[pv] < sz[pu]) swap(pv , pu); // union by rank
        par[pu] = pv;
        sz[pv] += sz[pu];
        return 1;
    }

    ll getSize(ll v){
        return sz[Find(v)];
    }
};

vector<pll> adj[MAXN];
vector<pair<pll , pll>> e;
ll n , m , v , u , w , H[MAXN] , ans[MAXN * 10];
pll par[MAXN][LOG];
DSU<MAXN> dsu;
map<pair<pll , pll> , ll> inMST;

void DFS(ll v , ll p = 0 , ll w = 0){
    H[v] = H[p] + 1;

    par[v][0] = {p , w};
    for(ll i = 1 ; i < LOG ; i++){
        par[v][i] = {par[par[v][i - 1].X][i - 1].X , max(par[par[v][i - 1].X][i - 1].Y , par[v][i - 1].Y)};
    }

    for(pll i : adj[v]){
        ll u = i.X , w = i.Y;
        if(u != p){
            DFS(u , v , w);
        }
    }
}

pll getPar(ll v , ll d){
    pll ans = {v , 0};
    for(ll i = 0 ; i < LOG ; i++){
        if(d & (1 << i)){
            ans = {par[ans.X][i].X , max(ans.Y , par[ans.X][i].Y)};
        }
    }
    return ans;
}

pll LCA(ll v , ll u){
    if(H[v] > H[u]) swap(v , u);
    pll ans = getPar(u , H[u] - H[v]);
    u = ans.X;

    if(u == v)  return ans;
    for(ll i = LOG - 1 ; i >= 0 ; i--){
        if(par[v][i].X != par[u][i].X){
            ans.Y = max({ans.Y , par[v][i].Y , par[u][i].Y});
            v = par[v][i].X;
            u = par[u][i].X;
        }
    }
    return {par[v][0].X , max({ans.Y , par[v][0].Y , par[u][0].Y})};
}

int main() {
    fast_io;
    fill(ans , ans + MAXN * 10 , -1);

    cin >> n >> m;
    for(ll i = 0 ; i < m ; i++){
        cin >> v >> u >> w;
        e.push_back({{w , i} , {v , u}});
    }

    sort(e.begin() , e.end());
    for(ll i = 0 ; i < m ; i++){
        ll w = e[i].X.X , v = e[i].Y.X , u = e[i].Y.Y;
        if(dsu.Union(v , u)){
            adj[v].push_back({u , w});
            adj[u].push_back({v , w});
            inMST[e[i]] = 1;
        }
    }

    DFS(1);
    for(ll i = 0 ; i < m ; i++){
        if(!inMST[e[i]]){
            v = e[i].Y.X , u = e[i].Y.Y;
            ans[e[i].X.Y] = LCA(v , u).Y;
        }
    }

    for(ll i = 0 ; i < m ; i++){
        if(ans[i] != -1){
            cout << ans[i] << endl;
        }
    }

    return 0;
}
/*

*/
