/*
 * @author khokharnikunj8
 */

#include <bits/stdc++.h>

using namespace std;

template<class T>
struct is_iterator {
    template<class U, typename enable_if<!is_convertible<U, const char *>::value, int>::type = 0>
    constexpr static auto has_indirection(int) -> decltype(*declval<U>(), bool()) { return true; }

    template<class>
    constexpr static bool has_indirection(long) { return false; }

    constexpr static bool value = has_indirection<T>(0);
};

using uint = unsigned int;
// Buffer size should be 2^12 or 2^13 for optimal performance with files.
const uint BUFFER_SIZE = 1 << 12;
// Maximum possible length of a string representing primitive type
// assuming we won't encounter huge double values.
const uint MAX_LENGTH = 1 << 7;

namespace Detail {
    struct Width {
        uint value;
    };
    struct Fill {
        char value;
    };
    struct Base {
        uint value;
    };
    struct Precision {
        uint value;
    };
    struct Delimiter {
        const char *value;
    };
}  // namespace Detail

Detail::Width setWidth(uint value = 0) { return {value}; }

Detail::Fill setFill(char value = ' ') { return {value}; }

Detail::Base setBase(uint value = 10) {
    assert(2 <= value && value <= 36);
    return {value};
}

Detail::Precision setPrecision(uint value = 9) {
    assert(value < MAX_LENGTH);
    return {value};
}

Detail::Delimiter setDelimiter(const char *value = " ") { return {value}; }

/******************************* input classes ********************************/
class InputDevice {
protected:
    const char *head;
    const char *tail;

    InputDevice(const char *head, const char *tail) : head(head), tail(tail), base(setBase().value) {}

    virtual void fillInput() = 0;

    inline char nextChar() {
        if (__builtin_expect(head >= tail, false)) fillInput();
        return *head++;
    }

    template<class I>
    int readUnsignedIntGeneral(I &arg, char c) {
        I value = 0;
        int length = 0;
        for (;; ++length, c = nextChar()) {
            if (isDigit(c)) c -= '0';
            else if (isUpper(c)) c -= 'A' - 10;
            else if (isLower(c)) c -= 'a' - 10;
            else c = base;
            if (c >= base) break;
            value = base * value + c;
        }
        arg = value;
        return --head, length;
    }

    template<class I>
    inline int readUnsignedInt(I &arg, char c) {
        if (__builtin_expect(base > 10, false)) return readUnsignedIntGeneral(arg, c);
        I value = 0;
        int length = 0;
        for (; static_cast<unsigned char>(c - '0') < base; ++length, c = nextChar())
            value = base * value + c - '0';
        arg = value;
        return --head, length;
    }

    template<class I>
    inline bool readSignedInt(I &arg, char c) {
        bool negative = c == '-';
        if (negative) c = nextChar();
        typename make_unsigned<I>::type unsignedArg;
        if (readUnsignedInt(unsignedArg, c) == 0) return false;
        arg = negative ? ~static_cast<I>(unsignedArg - 1) : static_cast<I>(unsignedArg);
        return true;
    }

    template<class F>
    bool readFloatingPoint(F &arg, char c) {
        bool negative = c == '-';
        if (negative) c = nextChar();
        unsigned long long integerPart;
        if (readUnsignedInt(integerPart, c) == 0) return false;
        arg = static_cast<F>(integerPart);
        if (nextChar() == '.') {
            unsigned long long fractionalPart = 0;
            int fractionalLength = readUnsignedInt(fractionalPart, nextChar());
            if (fractionalLength > 0) {
                unsigned long long basePower = 1;
                for (; fractionalLength; --fractionalLength) basePower *= base;
                arg += static_cast<F>(fractionalPart) / basePower;
            }
        } else --head;
        if (negative) arg = -arg;
        return true;
    }

public:
    uint base;

    InputDevice(InputDevice const &) = delete;

    InputDevice &operator=(InputDevice const &) = delete;

    static inline bool isSpace(char c) { return static_cast<unsigned char>(c - '\t') < 5 || c == ' '; }

    static inline bool isDigit(char c) { return static_cast<unsigned char>(c - '0') < 10; }

    static inline bool isUpper(char c) { return static_cast<unsigned char>(c - 'A') < 26; }

    static inline bool isLower(char c) { return static_cast<unsigned char>(c - 'a') < 26; }

    static inline bool isOneOf(char c, const char *str) { return strchr(str, c) != nullptr; }

    void putBack() { --head; }  // can be called only once directly after successfully reading a character

    inline bool readChar(char &arg) {
        if (__builtin_expect(head >= tail, false)) {
            fillInput();
            if (__builtin_expect(head >= tail, false)) return arg = '\0', false;
        }
        return arg = *head++, true;
    }

    template<class UnaryPredicate>
    inline char skipCharacters(UnaryPredicate isSkipped) {
        char c;
        do { c = nextChar(); } while (isSkipped(c));
        return c;
    }

    inline char skipCharacters() { return skipCharacters(isSpace); }

    template<class UnaryPredicate>
    inline int readString(char *arg, int limit, UnaryPredicate isTerminator) {
        skipCharacters(isTerminator);
        // put back first non-skipped character, reserve space for null character
        int charsRead = 0;
        for (--head, --limit; head < tail; fillInput()) {
            ptrdiff_t chunkSize = find_if(head, min(tail, head + limit - charsRead), isTerminator) - head;
            arg = copy_n(head, chunkSize, arg);
            head += chunkSize;
            charsRead += chunkSize;
            if (chunkSize == 0 || head < tail) break;
        }
        return *arg = '\0', charsRead;
    }

    inline int readString(char *arg, int limit, const char *terminators) {
        if (!*terminators) return readString(arg, limit, InputDevice::isSpace);
        return readString(arg, limit, [terminators](char c) { return InputDevice::isOneOf(c, terminators); });
    }

    // property setters
    inline bool read(Detail::Base newBase) {
        base = newBase.value;
        return true;
    }

    // primitive types
    inline bool read() { return true; }

    inline bool read(char &arg) { return readChar(arg); }

    template<class I>
    inline typename enable_if<is_integral<I>::value && is_unsigned<I>::value,
            bool>::type read(I &arg) { return readUnsignedInt(arg, skipCharacters()) > 0; }

    template<class I>
    inline typename enable_if<is_integral<I>::value && is_signed<I>::value,
            bool>::type read(I &arg) { return readSignedInt(arg, skipCharacters()); }

    template<class F>
    inline typename enable_if<is_floating_point<F>::value,
            bool>::type read(F &arg) { return readFloatingPoint(arg, skipCharacters()); }

    // characters skip
    inline bool read(const char &arg) {
        skipCharacters([arg](char c) { return arg != c; });
        return true;
    }

    inline bool read(const char *arg) {
        if (*arg) skipCharacters([arg](char c) { return InputDevice::isOneOf(c, arg); });
        else skipCharacters();
        return putBack(), true;
    }

    inline bool read(bool (*isSkipped)(char)) {
        skipCharacters(isSkipped);
        putBack();
        return true;
    }

    // strings
    template<class I, class Terminator, class... Ts>
    inline typename enable_if<is_integral<I>::value,
            bool>::type read(char *arg, I limit, Terminator terminator, Ts &&... args) {
        readString(arg, static_cast<int>(limit), terminator);
        return read(forward<Ts>(args)...);
    }

    template<class I>
    inline typename enable_if<is_integral<I>::value,
            bool>::type read(char *arg, I limit) { return read(arg, limit, ""); }

    template<class... Ts>
    inline bool read(char *first, char *last, Ts &&... args) {
        return read(first, static_cast<int>(last - first), forward<Ts>(args)...);
    }

    template<int N, class... Ts>
    inline bool read(char (&arg)[N], Ts &&... args) { return read(static_cast<char *>(arg), N, forward<Ts>(args)...); }

    template<class Terminator, class... Ts>
    inline bool read(string &arg, Terminator terminator, Ts &&... args) {
        for (int length = 16, last = 0;; last += length, length <<= 1) {
            arg.resize(last + length);
            int charsRead = readString(&arg[last], length + 1, terminator);
            if (charsRead < length) {
                arg.resize(last + charsRead);
                return read(forward<Ts>(args)...);
            }
        }
    }

    inline bool read(string &arg) { return read(arg, ""); }

    // complex types and ranges
    template<class T1, class T2>
    inline bool read(pair<T1, T2> &arg) { return read(arg.first, arg.second); }

    template<class T>
    inline bool read(complex<T> &arg) {
        T real, imag;
        if (!read(real, imag)) return false;
        arg.real(real), arg.imag(imag);
        return true;
    }

    template<class T>
    inline bool read(vector<T> &arg) {
        uint n;
        if (!read(n)) return false;
        arg.resize(n);
        return read(arg.begin(), arg.end());
    }

    template<class Iterator, class... Ts>
    inline typename enable_if<is_iterator<Iterator>::value,
            bool>::type read(Iterator first, Iterator last, Ts &&... args) {
        for (; first != last; ++first) if (!read(*first)) return false;
        return read(forward<Ts>(args)...);
    }

    template<class Iterator, class I, class... Ts>
    inline typename enable_if<is_iterator<Iterator>::value && is_integral<I>::value,
            bool>::type read(Iterator first, I count, Ts &&... args) {
        return read(first, first + count, forward<Ts>(args)...);
    }

    // generic forwarding
    template<class T>
    inline auto read(T &arg) -> decltype(arg.read(*this)) { return arg.read(*this); }

    template<class T0, class T1, class... Ts>
    inline typename enable_if<!is_iterator<T0>::value && !is_convertible<T0, char *>::value,
            bool>::type read(T0 &&arg0, T1 &&arg1, Ts &&... args) {
        return read(forward<T0>(arg0)) && read(forward<T1>(arg1), forward<Ts>(args)...);
    }
};

class InputFile : public InputDevice {
    FILE *file;
    bool lineBuffered;
    bool owner;
    char buffer[BUFFER_SIZE];

    void fillInput() override {
        head = buffer;
        *buffer = '\0';
        if (__builtin_expect(!lineBuffered, true)) {
            tail = head + fread(buffer, 1, BUFFER_SIZE, file);
        } else {
            tail = head;
            if (fgets(buffer, BUFFER_SIZE, file)) while (*tail) ++tail;
        }
    }

public:
    InputFile(FILE *file = stdin, bool lineBuffered = true, bool takeOwnership = false)
            : InputDevice(buffer, buffer), file(file), lineBuffered(lineBuffered), owner(takeOwnership) {}

    InputFile(const char *fileName) : InputFile(fopen(fileName, "r"), false, true) {}

    ~InputFile() { if (owner) fclose(file); }
};

// Picks up data appended to the string but doesn't handle reallocation.
class InputString : public InputDevice {
    void fillInput() override { while (*tail) ++tail; }

public:
    InputString(const string &s) : InputDevice(s.data(), s.data() + s.size()) {}

    InputString(const char *s) : InputDevice(s, s + strlen(s)) {}
};

/******************************* output classes *******************************/
class OutputDevice {
protected:
    char buffer[BUFFER_SIZE + MAX_LENGTH];
    char *output;
    char *end;
    bool separate;

    OutputDevice() : output(buffer), end(buffer + BUFFER_SIZE + MAX_LENGTH), separate(false), width(setWidth().value),
                     fill(setFill().value), base(setBase().value), precision(setPrecision().value),
                     delimiter(setDelimiter().value) { computeBasePower(); }

    virtual void writeToDevice(uint count) = 0;

    inline void flushMaybe() {
        if (__builtin_expect(output >= buffer + BUFFER_SIZE, false)) {
            writeToDevice(BUFFER_SIZE);
            output = copy(buffer + BUFFER_SIZE, output, buffer);
        }
    }

    void computeBasePower() {
        basePower = 1;
        for (uint i = 0; i < precision; ++i) basePower *= base;
    }

    template<class I>
    inline char *writeUnsignedInt(I arg, char *last) {
        if (__builtin_expect(arg == 0, false)) *--last = '0';
        if (__builtin_expect(base == 10, true)) {
            for (; arg; arg /= 10) *--last = '0' + arg % 10;
        } else
            for (; arg; arg /= base) {
                I digit = arg % base;
                *--last = digit < 10 ? '0' + digit : 'A' - 10 + digit;
            }
        return last;
    }

    template<class I>
    inline char *writeSignedInt(I arg, char *last) {
        auto unsignedArg = static_cast<typename make_unsigned<I>::type>(arg);
        if (arg < 0) {
            last = writeUnsignedInt(~unsignedArg + 1, last);
            *--last = '-';
            return last;
        }
        return writeUnsignedInt(unsignedArg, last);
    }

    template<class F>
    char *writeFloatingPoint(F arg, char *last) {
        bool negative = signbit(arg);
        if (negative) arg = -arg;
        if (isnan(arg)) for (int i = 0; i < 3; ++i) *--last = i["NaN"];
        else if (isinf(arg)) for (int i = 0; i < 3; ++i) *--last = i["fnI"];
        else {
            auto integerPart = static_cast<unsigned long long>(arg);
            auto fractionalPart = static_cast<unsigned long long>((arg - integerPart) * basePower + F(0.5));
            if (fractionalPart >= basePower) ++integerPart, fractionalPart = 0;
            char *point = last - precision;
            if (precision > 0) {
                ::fill(point, writeUnsignedInt(fractionalPart, last), '0');
                *--point = '.';
            }
            last = writeUnsignedInt(integerPart, point);
        }
        if (negative) *--last = '-';
        return last;
    }

    inline int writeT(char *first) {
        int delimiterLenght = separate ? writeDelimiter() : 0;
        separate = true;
        uint charsWritten = static_cast<uint>(end - first);
        if (__builtin_expect(charsWritten < width, false))
            charsWritten += writeFill(width - charsWritten);
        output = copy(first, end, output);
        flushMaybe();
        return delimiterLenght + static_cast<int>(charsWritten);
    }

    inline int writeFill(uint count) {
        int charsWritten = static_cast<int>(count);
        if (__builtin_expect(output + count + MAX_LENGTH < end, true)) {
            if (count == 1) *output++ = fill;
            else output = fill_n(output, count, fill);
        } else
            for (uint chunkSize = static_cast<uint>(buffer + BUFFER_SIZE - output);; chunkSize = BUFFER_SIZE) {
                if (chunkSize > count) chunkSize = count;
                output = fill_n(output, chunkSize, fill);
                flushMaybe();
                if ((count -= chunkSize) == 0) break;
            }
        return charsWritten;
    }

public:
    uint width;
    char fill;
    uint base;
    uint precision;
    unsigned long long basePower;
    string delimiter;

    OutputDevice(OutputDevice const &) = delete;

    OutputDevice &operator=(OutputDevice const &) = delete;

    virtual ~OutputDevice() {};

    inline int writeChar(char arg) {
        separate = false;
        *output++ = arg;
        flushMaybe();
        return 1;
    }

    inline int writeString(const char *arg, size_t length, bool checkWidth = true) {
        separate = false;
        uint count = static_cast<uint>(length);
        int charsWritten = static_cast<int>(count) + (checkWidth && count < width ? writeFill(width - count) : 0);
        if (__builtin_expect(output + count + MAX_LENGTH < end, true)) {
            if (count == 1) *output++ = *arg;
            else output = copy_n(arg, count, output);
        } else
            for (uint chunkSize = static_cast<uint>(buffer + BUFFER_SIZE - output);; chunkSize = BUFFER_SIZE) {
                if (chunkSize > count) chunkSize = count;
                output = copy_n(arg, chunkSize, output);
                flushMaybe();
                if ((count -= chunkSize) == 0) break;
                arg += chunkSize;
            }
        return charsWritten;
    }

    inline int writeDelimiter() { return writeString(delimiter.c_str(), delimiter.size(), false); }

    inline void flush() {
        writeToDevice(static_cast<uint>(output - buffer));
        output = buffer;
    }

    // property setters
    inline int write(Detail::Width newWidth) {
        width = newWidth.value;
        return 0;
    }

    inline int write(Detail::Fill newFill) {
        fill = newFill.value;
        return 0;
    }

    inline int write(Detail::Base newBase) {
        base = newBase.value;
        computeBasePower();
        return 0;
    }

    inline int write(Detail::Precision newPrecision) {
        precision = newPrecision.value;
        computeBasePower();
        return 0;
    }

    inline int write(Detail::Delimiter newDelimiter) {
        delimiter = newDelimiter.value;
        return 0;
    }

    // primitive types
    inline int write() { return 0; }

    inline int write(char arg) { return writeChar(arg); }

    template<class I>
    inline typename enable_if<is_integral<I>::value && is_unsigned<I>::value,
            int>::type write(I arg) { return writeT(writeUnsignedInt(arg, end)); }

    template<class I>
    inline typename enable_if<is_integral<I>::value && is_signed<I>::value,
            int>::type write(I arg) { return writeT(writeSignedInt(arg, end)); }

    template<class F>
    inline typename enable_if<is_floating_point<F>::value,
            int>::type write(F arg) { return writeT(writeFloatingPoint(arg, end)); }

    // complex types
    inline int write(const char *arg) { return writeString(arg, strlen(arg)); }

    template<int N>
    inline int write(char (&arg)[N]) { return writeString(arg, strlen(arg)); }

    inline int write(const string &arg) { return writeString(arg.c_str(), arg.size()); }

    template<class T1, class T2>
    inline int write(const pair<T1, T2> &arg) {
        int charsWritten = write(arg.first);
        charsWritten += writeDelimiter();
        return charsWritten + write(arg.second);
    }

    template<class T>
    inline int write(const complex<T> &arg) { return write(real(arg), imag(arg)); }

    // ranges
    template<class Iterator, class... Ts>
    inline typename enable_if<is_iterator<Iterator>::value,
            int>::type write(Iterator first, Iterator last, Ts &&... args) {
        int charsWritten = 0;
        for (; first != last; charsWritten += ++first == last ? 0 : writeDelimiter()) charsWritten += write(*first);
        return charsWritten + write(forward<Ts>(args)...);
    }

    template<class Iterator, class I, class... Ts>
    inline typename enable_if<is_iterator<Iterator>::value && is_integral<I>::value,
            int>::type write(Iterator first, I count, Ts &&... args) {
        return write(first, first + count, forward<Ts>(args)...);
    }

    // generic forwarding
    template<class T>
    inline auto write(const T &arg) -> decltype(arg.write(*this)) { return arg.write(*this); }

    template<class T0, class T1, class... Ts>
    inline typename enable_if<!is_iterator<T0>::value,
            int>::type write(T0 &&arg0, T1 &&arg1, Ts &&... args) {
        int charsWritten = write(forward<T0>(arg0));
        return charsWritten + write(forward<T1>(arg1), forward<Ts>(args)...);
    }
};

class OutputFile : public OutputDevice {
    FILE *file;
    bool owner;

    void writeToDevice(uint count) override {
        fwrite(buffer, 1, count, file);
        fflush(file);
    }

public:
    OutputFile(FILE *file = stdout, bool takeOwnership = false) : file(file), owner(takeOwnership) {}

    OutputFile(const char *fileName) : OutputFile(fopen(fileName, "w"), true) {}

    ~OutputFile() override {
        flush();
        if (owner) fclose(file);
    }
};

class OutputString : public OutputDevice {
    string &str;

    void writeToDevice(uint count) override { str.append(buffer, count); }

public:
    OutputString(string &str) : OutputDevice(), str(str) {}

    ~OutputString() override { flush(); }
};

unique_ptr<InputDevice> input;
unique_ptr<OutputDevice> output;

template<class... Ts>
inline bool read(Ts &&... args) { return input->read(forward<Ts>(args)...); }

template<class... Ts>
inline int write(Ts &&... args) { return output->write(forward<Ts>(args)...); }

template<class... Ts>
inline int writeln(Ts &&... args) { return write(forward<Ts>(args)..., '\n'); }

void flush() { output->flush(); }


struct FFT_mod {
    int mod, root, root_1, root_pw;
};

template<typename T>
T extGcd(T a, T b, T &x, T &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    } else {
        int g = extGcd(b, a % b, y, x);
        y -= a / b * x;
        return g;
    }
}

template<typename T>
T modInv(T a, T m) {
    T x, y;
    extGcd(a, m, x, y);
    return (x % m + m) % m;
}

FFT_mod suggested_fft_mods[5] = {
        {167772161, 243,       114609789, 1 << 25},
        {415236097, 73362476,  247718523, 1 << 22},
        {463470593, 428228038, 182429,    1 << 21},
        {998244353, 15311432,  469870224, 1 << 23},
        {918552577, 86995699,  324602258, 1 << 22}
};

int FFT_w[1050000];
int FFT_w_dash[1050000];


void ntt_shortmod(std::vector<int> &a, bool invert, const FFT_mod &mod_data) {
    // only use if mod < 5*10^8
    int n = (int) a.size();
    int mod = mod_data.mod;

    for (int i = 1, j = 0; i < n; ++i) {
        int bit = n >> 1;
        for (; j >= bit; bit >>= 1)
            j -= bit;
        j += bit;
        if (i < j)
            std::swap(a[i], a[j]);
    }

    for (int len = 2; len <= n; len <<= 1) {
        int wlen = invert ? mod_data.root_1 : mod_data.root;
        for (int i = len; i < mod_data.root_pw; i <<= 1)
            wlen = int(wlen * 1ll * wlen % mod_data.mod);
        long long tt = wlen;
        for (int i = 1; i < len / 2; i++) {
            FFT_w[i] = tt;
            FFT_w_dash[i] = (tt << 31) / mod;
            int q = (FFT_w_dash[1] * 1ll * tt) >> 31;
            tt = (wlen * 1ll * tt - q * 1ll * mod) & ((1LL << 31) - 1);
            if (tt >= mod) tt -= mod;
        }
        for (int i = 0; i < n; i += len) {
            int uu = a[i], vv = a[i + len / 2] % mod;
            if (uu >= 2 * mod) uu -= 2 * mod;
            a[i] = uu + vv;
            a[i + len / 2] = uu - vv + 2 * mod;

            for (int j = 1; j < len / 2; ++j) {
                int u = a[i + j];
                if (u >= 2 * mod) u -= 2 * mod;
                int q = (FFT_w_dash[j] * 1ll * a[i + j + len / 2]) >> 31;
                int v = (FFT_w[j] * 1ll * a[i + j + len / 2] - q * 1ll * mod) & ((1LL << 31) - 1);
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v + 2 * mod;
            }
        }
    }
    if (invert) {
        int nrev = modInv(n, mod);
        for (int i = 0; i < n; ++i)
            a[i] = int(a[i] * 1ll * nrev % mod);
    }
}


long long _fft_crt(const std::vector<std::pair<int, int> > &a, int mod, std::array<int, 3> &x,
                   std::array<std::array<int, 3>, 3> &modi) {
    long long res = 0;
    long long mult = 1;

    int SZ = a.size();
    for (int i = 0; i < SZ; ++i) {
        x[i] = a[i].first;
        for (int j = 0; j < i; ++j) {
            long long cur = (x[i] - x[j]) * 1ll * modi[j][i];
            x[i] = (int) (cur % a[i].second);
            if (x[i] < 0) x[i] += a[i].second;
        }
        res = (res + mult * 1ll * x[i]);
        mult = (mult * 1ll * a[i].second);
        if (mod != -1) {
            res %= mod;
            mult %= mod;
        }
    }

    return res;
}

void mul_mod_ip(std::vector<int> &a, std::vector<int> &b, int mod) {
    for (int i = 0; i < a.size(); i++) a[i] = (a[i] * 1ll * b[i]) % mod;
}

std::vector<int> conv_generic(std::vector<int> &a, std::vector<int> &b, int mod) {
    std::vector<int> at = a, bt = b, att = a, btt = b;
    ntt_shortmod(at, false, suggested_fft_mods[0]);
    ntt_shortmod(bt, false, suggested_fft_mods[0]);
    mul_mod_ip(at, bt, suggested_fft_mods[0].mod);
    ntt_shortmod(at, true, suggested_fft_mods[0]);

    bt = b;
    ntt_shortmod(att, false, suggested_fft_mods[1]);
    ntt_shortmod(bt, false, suggested_fft_mods[1]);
    mul_mod_ip(bt, att, suggested_fft_mods[1].mod);
    ntt_shortmod(bt, true, suggested_fft_mods[1]);

    att = a;
    ntt_shortmod(att, false, suggested_fft_mods[2]);
    ntt_shortmod(btt, false, suggested_fft_mods[2]);
    mul_mod_ip(att, btt, suggested_fft_mods[2].mod);
    ntt_shortmod(att, true, suggested_fft_mods[2]);

    std::array<int, 3> x;
    std::array<std::array<int, 3>, 3> modi;

    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            if (i != j) {
                modi[i][j] = modInv(suggested_fft_mods[i].mod, suggested_fft_mods[j].mod);
            }

    std::vector<std::pair<int, int>> crt_input(3);
    for (int i = 0; i < 3; i++) crt_input[i].second = suggested_fft_mods[i].mod;
    for (int i = 0; i < a.size(); i++) {
        crt_input[0].first = at[i];
        crt_input[1].first = bt[i];
        crt_input[2].first = att[i];
        //printf("%d->%d %d %d\n",i,at[i],bt[i],att[i]);
        btt[i] = _fft_crt(crt_input, mod, x, modi);
    }
    return btt;
}

int main() {
    input.reset(new InputFile());
    output.reset(new OutputFile());

    vector<int> ar(2097152);
    vector<int> br(2097152);
    int n, m, p;
    read(n, m, p);
    for (int i = 0; i < n; i++) read(ar[i]);
    for (int j = 0; j < m; j++) read(br[j]);
    vector<int> cr = conv_generic(ar, br, p);
    for (int i = 0;; i++)
        if (cr[i]) {
            write(i);
            return 0;
        }
    return 0;
}
