/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author marX
 */

#include <iostream>
#include <fstream>

#include <bits/stdc++.h>
#include <vector>

template<typename sum_type>
sum_type add(sum_type &a, sum_type &b) {
    return a + b;
}

template<typename any>
void pass(any &a, any &b, any &c) {}

template<
        typename node_type,
        typename update_type,
        void (*_update)(node_type &, update_type &),
        node_type (*merge)(node_type &, node_type &) = add<node_type>,
        void (*push_lazy)(node_type &, node_type &, node_type &) = pass<node_type>
>
class SegmentTree {
    std::vector<node_type> st;
    int n;

    void build(int p, int b, int e, std::function<node_type(int)> &data_fn) {
        if (b + 1 == e) {
            st[p] = data_fn(b);
        } else {
            int m = (b + e) >> 1, l = p << 1, r = l | 1;
            build(l, b, m, data_fn);
            build(r, m, e, data_fn);
            st[p] = merge(st[l], st[r]);
        }
    }

    node_type query(int p, int b, int e, int x, int y) {
        if (x <= b && e <= y) {
            return st[p];
        } else {
            int m = (b + e) >> 1, l = p << 1, r = l | 1;
            push_lazy(st[p], st[l], st[r]);

            if (x < m) {
                auto ans = query(l, b, m, x, y);

                if (m < y) {
                    auto nxt = query(r, m, e, x, y);
                    ans = merge(ans, nxt);
                }

                return ans;
            } else {
                return query(r, m, e, x, y);
            }
        }
    }

    void update(int p, int b, int e, int x, int y, update_type &value) {
        if (x <= b && e <= y) {
            _update(st[p], value);
        } else {
            int m = (b + e) >> 1, l = p << 1, r = l | 1;
            push_lazy(st[p], st[l], st[r]);
            if (x < m) update(l, b, m, x, y, value);
            if (m < y) update(r, m, e, x, y, value);
            st[p] = merge(st[l], st[r]);
        }
    }

public:

    SegmentTree(int n) : n(n) {
        st.resize(4 * n);
    }
    static SegmentTree from(int n, std::function<node_type(int)> data_fn) {
        SegmentTree st(n);
        st.build(1, 0, n, data_fn);
        return st;
    }

    node_type query(int left, int right) {
        if (right <= left)
            return node_type();
        return query(1, 0, n, left, right);
    }

    void update(int left, int right, update_type value) {
        if (right <= left)
            return;
        update(1, 0, n, left, right, value);
    }

    void update(int pos, update_type value) {
        update(pos, pos + 1, value);
    }
};


using namespace std;

const int mod = 1000000007;

void update(int &a, int &b) {
    a = 1LL * a * b % mod;
}

int merge(int &a, int &b) {
    return 1LL * a * b % mod;
}

int modpow(int a, int n) {
    int b = 1;

    while (n) {
        if (n & 1) {
            b = 1LL * b * a % mod;
        }
        n >>= 1;
        a = 1LL * a * a % mod;
    }

    return b;
}

typedef SegmentTree<int, int, update, merge> segment_tree;

class DNewYearAndConference {
public:
    void solve(std::istream &in, std::ostream &out) {
        default_random_engine generator;
        uniform_int_distribution<int> distribution(0, mod - 1);

        int n;
        in >> n;

        int d = 0;

        while (d <= n) {
            d = distribution(generator);
        }

        vector<int> pos(4 * n);

        vector<vector<int>> a(n, vector<int>(4));

        int t = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < 4; ++j) {
                in >> a[i][j];
                pos[t++] = a[i][j];
            }
        }

        sort(pos.begin(), pos.end());

        auto get = [&](int x) {
            return lower_bound(pos.begin(), pos.end(), x) - pos.begin();
        };

        pos.resize(unique(pos.begin(), pos.end()) - pos.begin());

        auto b0 = segment_tree::from(pos.size(), [&](int x) { return 1; });
        auto e0 = segment_tree::from(pos.size(), [&](int x) { return 1; });
        auto b1 = segment_tree::from(pos.size(), [&](int x) { return 1; });
        auto e1 = segment_tree::from(pos.size(), [&](int x) { return 1; });

        bool ok = true;

        int sz = pos.size();

        for (int i = 0; i < n && ok; ++i) {
            int x0 = get(a[i][0]), y0 = get(a[i][1]);
            int x1 = get(a[i][2]), y1 = get(a[i][3]);

            auto q_e0 = e0.query(x0, sz);
            auto q_b0 = y0 + 1 == sz ? 1 : b0.query(y0 + 1, sz);

            auto q_e1 = e1.query(x1, sz);
            auto q_b1 = y1 + 1 == sz ? 1 : b1.query(y1 + 1, sz);

            auto q0 = 1LL * q_e0 * modpow(q_b0, mod - 2) % mod;
            auto q1 = 1LL * q_e1 * modpow(q_b1, mod - 2) % mod;

            if (q0 != q1) {
                ok = false;
                break;
            }

            int c = (d - i) ^distribution(generator) % mod;

            b0.update(x0, c);
            e0.update(y0, c);
            b1.update(x1, c);
            e1.update(y1, c);
        }

        out << (ok ? "YES" : "NO") << '\n';
    }
};


int main() {
    DNewYearAndConference solver;
    std::istream &in(std::cin);
    std::ostream &out(std::cout);
    solver.solve(in, out);
    return 0;
}
