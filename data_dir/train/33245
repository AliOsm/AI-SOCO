/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author hell_hacker
 */

#include <bits/stdc++.h>

#define endl '\n'

/*
When you walk through a storm
Hold your head up high
And don't be afraid of the dark
At the end of the storm
There's a golden sky
And the sweet silver song
of the lark
Walk on, through the wind
Walk on, through the rain
Though your dreams be tossed
and blown
Walk on, walk on
With hope in your heart
And you'll never walk alone
YNWA
*/

//hell_hacker
//IT TAKES EVERYTHING and IT IS NOT LUCK
//PICK ME LAST -- COME OUT OF N^WHERE

#include <bits/stdc++.h>
using namespace std;

#define fo(i,n) for(i=0;i<n;++i)
#define forr(i,n) for(i=n-1;i>=0;--i)

#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define yolo "debug_statement"

typedef long long int ll;
typedef long double ld;
typedef pair<int,int> ii;
typedef vector<ii> vii;
typedef vector<int> vi;

const ll inf = 1e9;
const ld eps = 1e-9;
const ld pi=acos(-1);
const ll mod=1000000007;

ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}


int n;
ld a[105];
ld ans = 0.0;

bool cmp(ld a, ld b){
    return a > b;
}

class TaskB {
public:

//    ld solve(int cur){
//        if(cur == n)return 0.0;
//        return max(solve(),solve())
//    }



	void solve(std::istream& in, std::ostream& out) {
        in >> n;
        int i, j, k;
        for(i=0; i < n; ++i)
            in >> a[i];
        sort(a,a+n,cmp);

        ans = a[0];
        vector<ld>selected;
        selected.pb(a[0]);

        for(i=1;i<n;++i){
            ld ans2 = 0.0;
            //push temporarily
            selected.pb(a[i]);
//            cout << sz(selected) << endl;
            for(j=0;j<sz(selected);++j){
                auto prod = 1.0;
                for(k=0; k < sz(selected); ++k){
                    prod = prod * (j == k ? a[k] : 1.0 - a[k]);
                }
                ans2 = ans2 +  prod;
            }
//            cout << ans2 << endl;
            if(ans2 < ans)
                selected.pop_back();
            else
                ans = ans2;
        }

        out << fixed << setprecision(12) << ans << endl;
	}
};


int main() {
	ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
	TaskB solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}

