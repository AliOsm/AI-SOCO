
#pragma GCC optimize("Ofast")
#pragma GCC optimize ("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")


#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <random>
#include <iomanip>

#include <algorithm>
#include <vector>
#include <queue>
#include <string>
#include <stack>
#include <set>
#include <map>
#include <numeric>
#include <functional>
#include <deque>
#include <array>
#include <iterator>
#include <bitset>
#include <initializer_list>

#include <ext/rope>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>


using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;


#define add push_back
#define rem pop_back
#define F first
#define S second

#define ALL(x) x.begin(), x.end()
#define SORT(x) sort(ALL(x))
#define REV(x) reverse(ALL(x))
#define print(x) cout << #x << " = " << x << endl;
#define FILE_NAME file_name


#define forn( i, a, b ) for( int i = a; i <= b; i++ )
#define forv( i, a, b ) for( int i = a; i >= b; i-- )
#define sqr( x ) ( x ) * ( x )
#define gcd( a, b ) __gcd( a, b )
#define lcm( a, b ) ( ( a ) * ( ( b ) / gcd( a, b ) ) )


const double EPS = 1e-9;
const double PI = acos ( -1. );
const int mod = ( int ) 1e9 + 7; // 998244353
long long llinf = __INT64_MAX__;
int inf = INT_MAX;


template<typename T1, typename T2> auto max ( T1 a, T2 b ) { auto max = a > b ? a : b; return max; }
template<typename T1, typename T2> auto min ( T1 a, T2 b ) { auto min = a < b ? a : b; return min; }

template<typename T1, typename T2> void updmax ( T1 &a, T2 b ) { a = a > b ? a : b; }
template<typename T1, typename T2> void updmin ( T1 &a, T2 b ) { a = a < b ? a : b; }

template<class T, class C = null_type> using Tree = tree<T, C, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update>;

template<typename A, typename B, typename C> struct triple{ A first; B second; C third; };
template<typename A, typename B, typename C, typename D> struct kvadruple{ A first; B second; C third; D fouth; };


namespace io{

	template<typename A, typename B> ostream& operator << ( ostream &os, pair<A, B> &p ) { return os << p.first << " " << p.second; }
	template<typename A, typename B, typename C> ostream& operator << ( ostream &os, triple<A, B, C> &p ) { return os << p.first << " " << p.second << " " << p.third; }
	template<typename A, typename B, typename C, typename D> ostream& operator << ( ostream &os, kvadruple<A, B, C, D> &p ) { return os << p.first << " " << p.second << " " << p.third << " " << p.fouth; }
	template<typename A> ostream& operator << ( ostream &os, vector<A> &v ) { for( A p : v ) cout << p << " "; return os; }
	template<typename A, typename B> ostream& operator << ( ostream &os, vector<pair<A, B>> &v ) { for( auto p : v ) cout << p << endl; return os; }
	template<typename A, typename B> ostream& operator << ( ostream &os, map<A, B> &mp ) { for( auto it : mp ) os << it.first << " " << it.second << endl; return os; }
	template<typename A> ostream& operator << ( ostream &os, set<A> &st ) { for( A p : st ) cout << p << " "; return os; }

	template<typename A, typename B> istream& operator >> ( istream &is, pair<A, B> &p ) { return is >> p.first >> p.second; }
	template<typename A, typename B, typename C> istream& operator >> ( istream &is, triple<A, B, C> &p ) { return is >> p.first >> p.second >> p.third; }
	template<typename A, typename B, typename C, typename D> istream& operator >> ( istream &is, kvadruple<A, B, C, D> &p ) { return is >> p.first >> p.second >> p.third >> p.fouth; }
	template<typename A> istream& operator >> ( istream &is, vector<A> &v ) { for( A &p : v ) is >> p; return is; }
	template<typename A, typename B> istream& operator >> ( istream &is, vector<pair<A, B>> &v ) { for( auto &p : v ) is >> p.first >> p.second; return is; }

	template<typename A, typename B> inline void output( pair<A, B> &p ) { cout << "pair = {" << p.first << ", " << p.second << "}" << endl; }
	template<typename A, typename B, typename C> inline void output( triple<A, B, C> &t ) { cout << "triple = {" << t.first << ", " << t.second << ", " << t.third << "}" << endl; }
	template<typename A, typename B, typename C, typename D> inline void output( kvadruple<A, B, C, D> &k ) { cout << "kvadruple = {" << k.first << ", " << k.second << ", " << k.third << ", " << "}" << endl; }
	template<typename A, typename B> inline void output( map<A, B> &mp ){ cout << "map:" << endl; for( auto it: mp ) cout << "{" << it.first << ", " << it.second << "}" << endl; }
	template<typename A> inline void output( vector<A> &v ){ cout << "vector = {"; for( int i = 0; i < v.size(); i++ ){ cout << v[i]; if( i < v.size() - 1 ) cout << ", "; } cout << "}"; cout << endl; }
	template<typename A, typename B> inline void output( vector<pair<A, B>> &v ) { cout << "vector: " << endl; for( auto p : v ) cout << "{" << p.first << ", " << p.second << "}" << endl; }
	template<typename A> inline void output( set<A> &st ){ cout << "set = {"; for( A p : st ){ cout << p; if( p != *st.rbegin() ) cout << ", "; } cout << "}"; cout << endl; }

	int read(){ char c; int d = 1, x = 0; do c = getchar(); while( c == ' ' || c == '\n' ); if( c == '-' ) c = getchar(), d = -1; while( isdigit( c ) ){ x = x * 10 + c - '0'; c = getchar(); } return d * x;}

}

using namespace io;


namespace bit{

	inline void set( int &x, int i ){ x |= ( 1 << i ); }
	inline void reset( int &x, int i ){ x ^= ( 1 << i ); }
	inline bool check( int x, int i ){ return ( ( 1 << i ) & x ); }
	inline bool is_pow( int x ){ return x && !( x & ( x - 1 ) ); }
	inline short count( int x ){ return __builtin_popcount( x ); }
	inline int sub( int a, int b ){ return a & ( ~b ); }
	inline int low_bit( int x ){ return x & ( x - 1 ); }
	inline int high_bit( int x ){ x |= x >> 1; x |= x >> 2; x |= x >> 4; x |= x >> 8; x |= x >> 16; x |= x >> 32; return x - ( x >> 1 );  }

}

template<typename T> struct modular {

	static const T mod = ( int ) 1e9 + 7;

	T x = 0;
	modular(){}
	modular( int x ){ this -> x = norm( x ); }

	T norm( int a ) { while( a >= mod ) a -= mod; while( a < 0 ) a += mod; return a; }
	modular norm( modular m ){ return m.x = norm( m.x ); }

	modular operator - () { return modular( -x ); }
	modular operator ++ () { return modular( ++x ); }

	modular & operator += ( const modular &m ){ this -> x = norm( this -> x + m.x ); return *this; }
	modular & operator -= ( const modular &m ){ this -> x = norm( this -> x - m.x ); return *this; }
	modular & operator *= ( const modular &m ){ this -> x = ( 1ll * this -> x * m.x ) % mod; return *this; }
	modular & operator /= ( const modular &m ){ return *this *= inv( m ); }

	modular & operator += ( const int &x ){ this -> x = norm( this -> x + x ); return *this; }
	modular & operator -= ( const int &x ){ this -> x = norm( this -> x - x ); return *this; }
	modular & operator *= ( const int &x ){ this -> x = ( 1ll * this -> x * x) % mod; return *this; }
	modular & operator /= ( const int &x ){ return *this *= inv( modular( x ) ); }

	friend bool operator < ( modular &a, modular &b ) { return a.x < b.x; }
	friend bool operator == ( modular &a, modular &b ) { return a.x == b.x; }
	friend bool operator != ( modular &a, modular &b ) { return a.x != b.x; }

	friend modular operator + ( modular a, modular b ){ return a += b; }
	friend modular operator - ( modular a, modular b ){ return a -= b; }
	friend modular operator * ( modular a, modular b ){ return a *= b; }
	friend modular operator / ( modular a, modular b ){ return a /= b; }

	friend modular inv( modular m ){ return pow( m, mod - 2 ); }
	friend modular pow( modular m, long long n ){ modular res( 1 ); while( n ){ if( n & 1 ) res *= m; m *= m; n >>= 1; } return res; }
	friend modular mul( modular m, long long n ){ modular res; while( n ){ if( n & 1 ) res += m; m += m; n >>= 1; } return res; }

	friend ostream & operator << ( ostream &os, modular m ){ return os << m.x; }
	friend istream & operator >> ( istream &is, modular m ){ return is >> m.x; }

};


namespace number {

	int mod = ( int ) 1e9 + 7;

	inline int norm( int a ) { while( a < 0 ) a += mod; while( a >= mod ) a -= mod; return a; }
	inline int add( int a, int b ) { return norm( a + b ); }
	inline int sub( int a, int b ) { return norm( a - b ); }
	inline int mul( int a, int b, int m = mod ) { return ( 1ll * a * b ) % m; }

	int pow_mod( int a, int n, int m = mod ) { int p = 1; while( n ) { if( n & 1 ) p = mul( p, a, m ); a = mul( a, a, m ); n >>= 1; } return p; }
	int mul_mod( int a, int n, int m = mod ) { int s = 0; while( n ) { if( n & 1 ) s = ( s + a ) % m; a = ( a + a ) % m; n >>= 1; } return s; }

	inline int inv( int a ) { return pow_mod( a, mod - 2 ); }
	inline int div_mod( int a, int b ) { return mul( a, inv( b ) ); }

	bool miller_rabin( long long m ) {
		random_device rd; mt19937 mt( rd( ) );
		uniform_int_distribution<int> dist( 0, llinf );
		int s = 0, d = m - 1;
		while( d % 2 == 0 ) s++, d /= 2;
		int a = 1 + dist( mt ) % ( m - 1 );
		int x = pow_mod( a, d, m );
		if( x == 1 ) return true;
		for( int r = 0; r < s; r++ ) { if( x == m - 1 ) return true; x = mul_mod( x, x, m ); }
		return false;
	}

	bool is_prime( long long n ) {
		if( n <= 4 ) return n == 2 || n == 3; if( n > 1e12 ) return miller_rabin( n );
		for( int i = 5; i * i <= n; i += 6 ) if( n % i == 0 || n % ( i + 2 ) == 0 ) return 0; return 1;
	}

	long long pollard_rho( long long n, int it = 50000 ) {
		random_device rd; mt19937 mt( rd( ) );
		uniform_int_distribution<int> dist( 0, llinf );
		long long b0 = dist( mt ) % n, b1 = b0, g;
		b1 = mul_mod( b1, b1, n );
		if( ++b1 == n ) b1 = 0;
		g = gcd( abs( b1 - b0 ), n );
		for( int count = 0; count < it && ( g == 1 || g == n ); count++ ) {
			b0 = mul_mod( b0, b0, n );
			if( ++b0 == n ) b0 = 0;
			b1 = mul_mod( b1, b1, n ); ++b1;
			b1 = mul_mod( b1, b1, n );
			if( ++b1 == n )	b1 = 0;
			g = gcd( abs( b1 - b0 ), n );
		}
		return g;
	}

	int gcdex( int a, int b, int & x, int & y ) {
		if( a == 0 ) { x = 0; y = 1; return b; }
		int x1, y1, d = gcdex( b % a, a, x1, y1 );
		x = y1 - ( b / a ) * x1; y = x1;
		return d;
	}
}


int dx[] = { 1, -1, 0, 0 };
int dy[] = { 0, 0, -1, 1 };
int Dx[] = { 1, 0, -1, 0, 1, 1, -1, -1 };
int Dy[] = { 0, 1, 0, -1, 1, -1, 1, -1 };


static const int MAXN = ( int ) 5e5 + 10;
static int a[MAXN], b[MAXN];


int n, m, k;
int res, cnt;
string s, t;
string ans;

bool cmp( string a, string b )
{
	if( b.empty( ) ) return 1;
	if( a.size() < b.size() ) return 1;
	if( a.size() > b.size() ) return 0;
	return a < b;
}
void solve( int k ){
	string t = s.substr( 0, k );
	string s_;
	while( s_.size() < n ) s_ += t;
	if( cmp( s, s_ ) ){
		if( cmp( s_, ans ) )
			ans = s_;
	} else {
		bool f = 1;
		for( int i = 0; i < k; i++ ){
			if( s[i] != '9' ){
				f = 0;
				break;
			}
		}
		if( f ){
			for( int i = 0; i < k; i++ ) t[i] = '0';
			t[0] = '1';
			s_.clear();
			while( s_.size() < n ) s_ += t;
			if( s_ < s ) s_ += t;
			while( s_.size() % m ) s_ += t;
			if( cmp( s_, ans ) ){
				ans = s_;
			}
		} else {
			t.back()++;
			if( t.back() > '9' ){
				t.back() = '0';
				int i = k - 2;
				while( t[i] == '9' ) t[i] = '0', i--;
				t[i]++;
			}
			s_.clear();
			while( s_.size() < n ) s_ += t;
			if( s_ < s ) s_ += t;
			while( s_.size() % m ) s_ += t;
			if( cmp( s_, ans ) ){
				ans = s_;
			}
		}
	}

}
bool check( string s_ )
{
	if( !cmp( s, s_ ) ) return 0;
	string t = s_.substr( 0, k );
	if( s_.size() % k ) return 0;
	for( int i = 0; i < s_.size(); i += k )
		if( s_.substr( i, k ) != t )
			return 0;
	return 1;
}
void solution()
{
	cin >> k >> s;
	/*
	s = "";
	k = rand() % 4 + 1;
	int q = rand() % 4 + 1;
	for( int i = 0; i < q; i++ )
		s += char( rand() % 10 + '0' );
	cout << k << " " << s << endl;
    	ans = "";
    	for( int i = 1; ; i++ )
    		if( check( to_string( i ) ) ){
    			cout << i << endl;
    			break;
    		}
	*/
    	m = k;
    	n = s.size();
    	int N = n;
    	if( k > n ){
    		cout << '1';
    		for( int i = 0; i < k - 1; i++ )
    			cout << '0';
    		cout << endl;
    	} else if( n % k == 0 ){
    		for( int i = 1; i <= k; i++ )
    			if( k % i == 0 )
    				solve( i );
    		cout << ans << endl;
    	} else {
		string t;
		string s_;
		for( int i = 0; i < k; i++ ) t += '0';
		t[0] = '1';
		s_.clear();
		while( s_.size() < n ) s_ += t;
		cout << s_ << endl;
    	}


}


int32_t main ( )
{

	int T1 = clock();

        //freopen("FILE_NAME.in", "r", stdin);
        //freopen("FILE_NAME.out", "w", stdout);

        ios_base::sync_with_stdio ( false ); cin.tie ( nullptr ); cout.tie ( nullptr );
        //cout.precision(15);

        int query = 1;
        //cin >> query;

	//random_device rd;
	//mt19937 mt( rd( ) );
	//uniform_int_distribution<int> dist( 0, llinf );

        while ( query-- ) solution();

	int T2 = clock();

        cerr << "Time: " << ( T2 - T1 ) / 1000. << " s." << endl;

        return 0;

}
