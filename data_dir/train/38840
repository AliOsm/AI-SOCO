/**************************************************************
    Problem: ????
    User: little_Bear_c
    Language: GNU_C++11
    Result: Accepted
    Time:0 ms
    Memory:0 kb
    length:0 kb
    score: inf
****************************************************************/
//CLOCKS_PER_SEC
using namespace std;
#include<bitset>
#include<deque>
#include<stdint.h>
#include<set>
#include<stack>
#include <iostream>
#include <algorithm>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<iomanip>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>
#include<ctime>
#include<map>
#define sqr(x) (x)*(x)
#define sort stable_sort
#define ll long long
#define mk make_pair
#define pb push_back
#define in insert
#define mtr(x,y,z) mk(mk(x,y),z)
#define fi first
#define se second
#define lch(x) ((x)<<1)
#define rch(x) (((x)<<1)|1)
#define all(x) (x).begin(),(x).end()
#define titose CLOCKS_PER_SEC
#define fpi(x) freopen(x,"r",stdin);
#define fpo(x) freopen(x,"w",stdout);
#define fprio fpi("in.txt");fpo("out.txt");
#define fast ios_base::sync_with_stdio(false);
void read(int &x){int v=0,f=1;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}
void read(ll &x){ll v=0ll,f=1ll;char c=getchar();while (!isdigit(c)&&c!='-') c=getchar();if (c=='-') f=-1; else v=v*10+c-'0';while (isdigit(c=getchar())) v=v*10+c-'0';x=v*f;}
void readc(char &x){char c;while ((c=getchar())==' ');x=c;}
void writes(string s){puts(s.c_str());}
void writeln(){writes("");}
void writei(int x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}
void writell(ll x){if (x<0){putchar('-');x=abs(x);}if (!x) putchar('0');char a[25];int top=0;while (x){a[++top]=(x%10)+'0';x/=10;}while (top){putchar(a[top]);top--;}}
/*
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("Ofast,no-stack-protector")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(4)
#pragma GCC optimize(5)
#pragma GCC optimize(6)
#pragma GCC optimize(7)
#pragma GCC optimize(8)
#pragma GCC optimize(9)
*/
inline long long inc(int &x){return ++x;}
inline long long inc(long long &x){return ++x;}
inline long long inc(int &x,long long y){return x+=y;}
inline long long inc(long long &x,long long y){return x+=y;}
inline double inc(double &x,double y){return x+=y;}
inline long long dec(int &x){return --x;}
inline long long dec(long long &x){return --x;}
inline long long dec(int &x,long long y){return x-=y;}
inline long long dec(long long &x,long long y){return x-=y;}
inline double dec(double &x,double y){return x-=y;}
inline long long mul(int &x){return x=((long long)x)*x;}
inline long long mul(long long &x){return x=x*x;}
inline long long mul(int &x,long long y){return x*=y;}
inline long long mul(long long &x,long long y){return x*=y;}
inline double mul(double &x,double y){return x*=y;}
inline long long divi(const int &x)
{
	long long ans,l,r,mid;
	ans=0;l=0;r=0x3fffffff;
	while (l<r)
	{
		mid=(l+r)/2;
		if (mid*mid<=x)
		{
			ans=mid;
			l=mid+1;
		}
		else r=mid;
	}
	return ans;
}
inline long long divi(const long long &x)
{
	long long ans,l,r,mid;
	ans=0;l=0;r=0x3fffffff;
	while (l<r)
	{
		mid=(l+r)/2;
		if (mid*mid<=x)
		{
			ans=mid;
			l=mid+1;
		}
		else r=mid;
	}
	return ans;
}
inline long long divi(int &x,long long y){return x/=y;}
inline long long divi(long long &x,long long y){return x/=y;}
inline double divi(double &x,double y){return x/=y;}
inline long long mod(int &x,long long y){return x%=y;}
inline long long mod(long long &x,long long y){return x%=y;}
#define pii pair<int,int>
#define pll pair<ll,ll>
#define vi vector<int>
#define vl vector<ll>
#define si set<int>
#define sl set<ll>
#define mii map<int,int>
#define mll map<ll,ll>
#define msi map<string,int>
#define msl map<string,ll>
#define piii pair<int,pii >
#define piipi pair<pii,int>
#define plll pair<ll,pll >
#define pllpl pair<pll,ll>
#define pqi priority_queue<int>
#define pql priority_queue<ll>
#define npqi priority_queue<int,vector<int>,greater<int> >
#define npql priority_queue<ll,vector<ll>,greater<ll> >
#define forup(i,x,y) if ((x)<=(y)) for ((i)=(x);(i)<=(y);(i)++)
#define fordo(i,x,y) if ((x)>=(y)) for ((i)=(x);(i)>=(y);(i)--)
#define rep(i,x) forup ((i),1,(x))
#define repd(i,x) fordo ((i),(x),1)
#define itr iterator
#define forwyx(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)
#define NO {cout<<"NO";return 0;}
#define YES {cout<<"YES";return 0;}
#define y0 y000000000000000000000000000
#define y1 y111111111111111111111111111
#define j0 j000000000000000000000000000
#define j1 j111111111111111111111111111
#define cl0(a) memset((a),(0),(sizeof((a))))
#define clz(a) memset((a),(0x16),(sizeof((a))))
#define clf(a) memset((a),(-(0x16)),(sizeof((a))))
#define inf 0x3bbbbbbb
#define lnf 0x1bbbbbbbbbbbbbbbll
#define sqrt divi
#define p2(i) (1ll<<(i))
#define readi read
#define readll read
/*************************************************/
int n,m,i,j,dis[21777],cnt,x,y,z,op,typ[5005],bel[5005],l[21777],r[21777],s=0,t=21775;
vector<pair<pair<int,int>,int> > v;
struct ed
{
	int fr,y,c,re,id;
}e[380005];
vector<int> bi[21777];
void init()
{
	int i;
	cnt=0;
	for (i=1;i<=n;i++) bi[i].clear();
}
bool bfs(int st,int ed)
{
	int i;
	queue<int> qx;
	memset(dis,-1,sizeof(dis));
	dis[st]=0;
	qx.push(st);
	while (!qx.empty())
	{
		int x=qx.front();
		qx.pop();
		for (i=0;i<bi[x].size();i++)
		{
			if (e[bi[x][i]].y!=st&&e[bi[x][i]].c>0&&dis[e[bi[x][i]].y]==-1)
			{
				dis[e[bi[x][i]].y]=dis[x]+1;
				qx.push(e[bi[x][i]].y);
			}
		}
	}
	if (dis[ed]==-1) return 0;
	return 1;
}
int dfs(int x,int ed,int flw)
{
	if (x==ed)
	{
		return flw;
	}
	int i,res=0;
	for (i=0;i<bi[x].size();i++)
	{
		if (dis[x]+1==dis[e[bi[x][i]].y]&&e[bi[x][i]].c>0)
		{  
        	int t=dfs(e[bi[x][i]].y,ed,min(e[bi[x][i]].c,flw));
    		e[bi[x][i]].c-=t;  
        	e[e[bi[x][i]].re].c+=t;  
        	flw-=t;  
        	res+=t;  
        	if (flw<1) break;  
    	}
	}
	if (res==0) dis[x]=-123456;
	return res;
}  
int maxflow(int st,int ed)
{
	int ans=0;
	while (bfs(st,ed)) ans+=dfs(st,ed,0x22222222);
	return ans;
}
void add(int x,int y,int sz,int id=0)
{
	cnt+=2;
	e[cnt-1]={x,y,sz,cnt,id};
	e[cnt]={y,x,0,cnt-1,id};
	bi[x].push_back(cnt-1);
	bi[y].push_back(cnt);
}
void build(int x,int le,int ri)
{
	l[x]=le;r[x]=ri;
	if (le==ri) return;
	add(x+n,x*2+n,10000);
	add(x+n,x*2+1+n,10000);
	build(x*2,le,(le+ri)/2);
	build(x*2+1,(le+ri)/2+1,ri);
}
void upd(int fr,int x,int le,int ri)
{
	if (l[x]>ri||r[x]<le) return;
	if (l[x]>=le&&r[x]<=ri)
	{
		add(fr,x+n,1);
		return;
	}
	upd(fr,x*2,le,ri);
	upd(fr,x*2+1,le,ri);
}
bool cmp(pair<pii,int> x,pair<pii,int> y)
{
	return mk(mk(x.fi.se,x.fi.fi),x.se)<mk(mk(y.fi.se,y.fi.fi),y.se);
}
int main()
{
	fast;
	cin>>n>>m;
	build(1,1,8192);
	rep(i,n)
	{
		cin>>op;typ[i]=op;
		if (op==0)
		{
			cin>>x;
			while (x--)
			{
				cin>>y;
				add(i,8191+y+n,1);
			}
		}
		if (op==1)
		{
			cin>>x>>y;
			upd(i,1,x,y);
			v.pb(mk(mk(y,x),i));
		}
		if (op==2)
		{
			cin>>x>>y>>z;
			add(i,8191+x+n,1);
			add(i,8191+y+n,1);
			add(i,8191+z+n,1);
		}
	}
	sort(all(v),cmp);
	for (i=1;i<=n;i++)
	{
		if (typ[i]==2) add(s,i,2);
	}
	for (i=1;i<=n;i++)
	{
		if (typ[i]!=2) add(s,i,1);
	}
	for (i=1;i<=m;i++) add(i+8191+n,t,1);
	cout<<maxflow(s,t)<<endl;
	for (i=1;i<=m;i++)
	{
		forwyx(it,bi[i+n+8191])
		{
			if (e[*it].y!=t&&e[*it].c>0)
			{
				bel[i]=e[*it].y;
			}
		}
	}
	set<pair<pair<int,int>,int> > s;
	int pnt=0;
	for (i=1;i<=m;i++)
	{
		if (bel[i]>n||typ[bel[i]]==1)
		{
			while (pnt<v.size()&&v[pnt].fi.se<=i) s.in(v[pnt++]);
			while (!s.empty()&&s.begin()->fi.fi<i) s.erase(s.begin());
			bel[i]=0;
			if (!s.empty())
			{
				bel[i]=s.begin()->se;
				s.erase(s.begin());
			}
		}
	}
	rep(i,m) if (bel[i]) cout<<bel[i]<<' '<<i<<endl;
	return 0;
}