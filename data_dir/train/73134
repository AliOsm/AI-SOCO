/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author
 */


#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

#define int long long

using namespace std;

class DMultipleTestcases {
public:
	void solve(std::istream& in, std::ostream& out) {
        int n, k; in >> n >> k;
        vector<int> sizes(n);
        for(int i = 0; i < n; ++i) in >> sizes[i];

        vector<pair<int, int>> constraint; // (max sz, count)
        for(int i = 0; i < k; ++i) {
            int ci; in >> ci;
            if(!constraint.empty() and constraint.back().second == ci) constraint.pop_back();
            constraint.emplace_back(i+1, ci);
        }

        sort(sizes.rbegin(), sizes.rend());

        set<pair<pair<int, int>, pair<int, int>>> testCases; //( (max sz, cid), (idx, cur_count) )

        vector<vector<int>> res(n);
        int idx = -1;
        for(int i = 0; i < n; ++i) {
            int sz = sizes[i];

            if(testCases.empty() or prev(testCases.end())->first.first < sz) {
                testCases.insert({{constraint.back().first, constraint.size() - 1}, {++idx, 0}});
            }

            auto bestCase = *prev(testCases.end());
            testCases.erase(prev(testCases.end()));

            res[bestCase.second.first].push_back(sz);
            bestCase.second.second += 1;
            if(bestCase.second.second == constraint[bestCase.first.second].second) {
                bestCase.first.second -= 1;
                if(bestCase.first.second >= 0) bestCase.first.first = constraint[bestCase.first.second].first;
            }
            if(bestCase.first.second >= 0) {
                testCases.insert(bestCase);
            }
        }

        out << idx+1 << '\n';
        for(int i = 0; i <= idx; ++i) {
            out << res[i].size() << ' ';
            for(auto x: res[i]) out << x << ' ';
            out << '\n';
        }

	}
};


int32_t main() {
	DMultipleTestcases solver;
	std::istream& in(std::cin);
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
